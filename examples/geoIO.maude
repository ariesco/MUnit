load GEO2D.maude
load GEO2D-Aux.maude

fmod GEO-SIGNATURE is
  inc FULL-MAUDE-SIGN .

  sorts @GeoCommand@ .
  subsort @GeoCommand@ < @Input@ .

  op point_as_ : @Bubble@ @Token@ -> @GeoCommand@ [ctor] .
  op circumference_in_with`radius_ : @Token@ @Token@ @Bubble@ -> @GeoCommand@ [ctor] .
  op line_from_to_ : @Token@ @Token@ @Token@ -> @GeoCommand@ [ctor] . 
  op cut`point_and_of_and_ : @Token@ @Token@ @Token@ @Token@ -> @GeoCommand@ [ctor] .
  op cut`point`of_and_ : @Token@ @Token@ -> @GeoCommand@ [ctor] .

endfm

fmod META-GEO-SIGN is
 inc META-FULL-MAUDE-SIGN .
 inc UNIT .

 op GEO-GRAMMAR : -> FModule [memo] .
 eq GEO-GRAMMAR = addImports((including 'GEO-SIGNATURE .), GRAMMAR) .
endfm


fmod GEO-COMMAND-PROCESSING is
 pr COMMAND-PROCESSING .
 pr DICC-FIGURAS .
 pr GEO2D .

 vars T T' T'' NP NC NR : Term .
 vars Q Q' Q'' name1 name2 : Qid .
 vars S S' : String .
 vars F F' : Float .
 vars P1 P2 p1 p2 : Punto .
 vars f1 f2 : Figura .
 vars 1entrada 2entrada : Entry .

 op processPoint : Term Term -> Entry .
 eq processPoint('bubble[T], 'token[NP]) = downQid(NP) -> processPointAux(T) .

 op processPointAux : Term -> Punto .
 ceq processPointAux('__[T, T']) = qid2point(Q, Q')
  if Q := downQid(T) /\
     Q' := downQid(T') .

 op qid2point : Qid Qid -> Punto .
 ceq qid2point(Q, Q') = p(F F')
  if S := string(Q) /\
     S' := string(Q') /\
     F := float(S) /\
     F' := float(S') .

 op processCircumference : Term Punto Term -> Entry .
 ceq processCircumference('token[NC] , P1 , 'bubble[T]) = downQid(NC) -> c(P1 , F) 
  if Q := downQid(T)
  /\ S := string(Q)
  /\ F := float(S) .
     
 op processLine : Term Punto Punto -> Entry .
 eq processLine('token[NR] , P1 , P2) = downQid(NR) -> r(P1 P2) .

 op processCutPoint : Term Term Figura Figura -> Dic .
 ceq processCutPoint('token[T] , 'token[T'] , f1 , f2) = processCutPointAux(p1, p2, f1, f2, 1entrada,2entrada) 
  if p1 := primer-elemento(pto-corte(f1 , f2))
  /\ p2 := primer-elemento(quitar-primer-elemento(pto-corte(f1 , f2)))
  /\ 1entrada := downQid(T) -> p1 
  /\ 2entrada := downQid(T') -> p2 .

 op processCutPointAux : Punto Punto Figura Figura Entry Entry -> Dic .
 ceq processCutPointAux(p1, p2, f1, f2, 1entrada, 2entrada) = 1entrada . 2entrada
  if not p1 == p2 
  /\ long-lista(pto-corte(f1 , f2)) == 2.0 .
 ceq processCutPointAux(p1, p2, f1, f2, 1entrada, 2entrada) = 1entrada
  if p1 == p2 
  /\ long-lista(pto-corte(f1 , f2)) == 2.0 .
 ceq processCutPointAux(p1, p2, f1, f2, 1entrada, 2entrada) = 1entrada
  if long-lista(pto-corte(f1 , f2)) == 1.0 .
 ceq processCutPointAux(p1, p2, f1, f2, 1entrada, 2entrada) = mtD
  if long-lista(pto-corte(f1 , f2)) == 0.0 .

 op new-name : Qid Qid -> Qid .
 eq new-name(name1, name2) = qid(string(name1) + string(name2)) .


endfm

mod GEO-DATABASE-HANDLING is
 pr GEO-COMMAND-PROCESSING .
 inc DATABASE-HANDLING .
 pr DICC-FIGURAS .

 sort GEODatabaseClass .
 subsort GEODatabaseClass < DatabaseClass .

 var  MUDC : GEODatabaseClass .
 var  AtS : AttributeSet .
 var  DB : Database .
 vars T1 T2 T3 T4 : Term .
 var  F F' : Figura .
 var  O : Oid .
 var  D : DicFiguras .
 var  D' : Dic .
 var  Q Q' : Qid .

 op dic :_ : DicFiguras -> Attribute [ctor] .

 crl [point] :
     < O : MUDC | input : ('point_as_[T1 , T2]), dic : D,
                  output : nil, AtS >
  => < O : MUDC | input : nilTermList, dic : (D [Q / F]),
                  output : ('Punto 'almacenado) , AtS >
  if Q -> F := processPoint(T1 , T2) .

 crl [circumference] :
     < O : MUDC | input : ('circumference_in_with`radius_[T1 , 'token[T2] , T3]), dic : D,
                  output : nil, AtS >
  => < O : MUDC | input : nilTermList, dic : (D [Q / F]),
                  output : ('Circunferencia 'almacenada) , AtS >
  if Q -> F := processCircumference(T1 , D[downQid(T2)] , T3) .

 crl [line] :
     < O : MUDC | input : ('line_from_to_[T1 , 'token[T2] , 'token[T3]]), dic : D,
                  output : nil, AtS >
  => < O : MUDC | input : nilTermList, dic : (D [Q / F]),
                  output : ('Recta 'almacenada) , AtS >
  if Q -> F := processLine(T1 , D[downQid(T2)] , D[downQid(T3)]) . 


 crl [cut1] :
     < O : MUDC | input : ('cut`point_and_of_and_[T1, T2, 'token[T3], 'token[T4]]), dic : D, 
                  output : nil, AtS >
  => < O : MUDC | input : nilTermList, dic : (D U [D' , mtD , mtD]),
                  output : ('Puntos 'almacenados) , AtS >
  if D' := processCutPoint(T1 , T2 , D[downQid(T3)] , D[downQid(T4)]) . 


 crl [cut2] :
     < O : MUDC | input : ('cut`point`of_and_['token[T3], 'token[T4]]), dic : D, 
                  output : nil, AtS >
  => < O : MUDC | input : nilTermList, dic : (D U [D' , mtD , mtD]),
                  output : ('Puntos 'almacenados) , AtS >
  if D' := processCutPoint(new-name(downQid(T3), downQid(T4)), new-name(downQid(T4), downQid(T3)) , D[downQid(T3)] , D[downQid(T4)]) . 


endm

mod MUNIT is
 inc GEO-DATABASE-HANDLING .
 inc META-GEO-SIGN .
 inc LOOP-MODE .

 var  QI : Qid .
 vars QIL QIL' QIL'' : QidList .
 var  Atts : AttributeSet .
 var  N : Nat .
 var  DB : Database .
 vars RP RP' : ResultPair .
 var  O : Oid .
 var  X@Database : DatabaseClass .

 op o : -> Oid [ctor] .

 op GEODatabase : -> GEODatabaseClass [ctor] .

 --- State for LOOP mode:
 subsort Object < State .
 op init-geo : -> System .

 op init-state : -> AttributeSet .
 eq init-state = dic : [mtD, mtD, mtD], db : initialDatabase, default : 'CONVERSION . 
 op geo-banner : -> QidList .
 eq geo-banner = '\n '\t 'GEO: 'GEO2D 'a 'unit 'testing 'framework 'for 'Maude.
           '\n '\t ' '\t '`( 'October '27th '`, '\s '2016 '`) '\n .

 rl [init] :
    init-geo
 => [nil, < o : GEODatabase | input : nilTermList, output : nil,
                              init-state >, geo-banner] .

 crl [in] :
     [QIL, < O : X@Database | input : nilTermList, Atts >, QIL']
  => [nil,
      < O : X@Database | input : getTerm(metaParse(GEO-GRAMMAR, QIL, '@Input@)), Atts >,
      QIL']
  if QIL =/= nil /\
     metaParse(GEO-GRAMMAR, QIL, '@Input@) : ResultPair .

 crl [in] :
     [QIL, < O : X@Database | output : nil, Atts >, QIL']
  => [nil,
      < O : X@Database | output : ('\r 'Warning: '\o
                printSyntaxError(metaParse(GEO-GRAMMAR, QIL, '@Input@), QIL)
                '\n
                '\r 'Error: '\o 'No 'parse 'for 'input. '\n), Atts >,
      QIL']
  if QIL =/= nil /\
     noParse(N) := metaParse(GEO-GRAMMAR, QIL, '@Input@)  .

 crl [in] :
     [QIL, < O : X@Database | output : nil, Atts >, QIL']
  => [nil,
      < O : X@Database | output :  ('\r 'Error: '\o 'Ambiguous 'input. '\n), Atts >,
      QIL']
   if QIL =/= nil /\
      ambiguity(RP, RP') := metaParse(GEO-GRAMMAR, QIL, '@Input@)  .

 rl [out] :
    [QIL, < O : X@Database | output : (QI QIL'), Atts >, QIL'']
 => [QIL, < O : X@Database | output : nil, Atts >, (QIL'' QI QIL')] .
endm

set print conceal on .
print conceal mod_is_sorts_._____endm .
print conceal fmod_is_sorts_.____endfm .
print conceal db .

loop init-geo .
