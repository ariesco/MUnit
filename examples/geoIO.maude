load GEO2D.maude
load GEO2D-Aux.maude

fmod GEO-SIGNATURE is
  inc FULL-MAUDE-SIGN .

  sorts @GeoCommand@ .
  subsort @GeoCommand@ < @Input@ .

  op point_as_ : @Bubble@ @Token@ -> @GeoCommand@ [ctor] .
  op circumference_in_with`radius_ : @Token@ @Token@ @Bubble@ -> @GeoCommand@ [ctor] .
  op circumference_in_with`radius`distance`from_to_ : @Token@ @Token@ @Token@ @Token@ -> @GeoCommand@ [ctor] . 
  op circumference`in_with`radius`distance`from_to_ : @Token@ @Token@ @Token@ ->  @GeoCommand@ [ctor] . 
  op line_from_to_ : @Token@ @Token@ @Token@ -> @GeoCommand@ [ctor] .
  op line`from_to_ : @Token@ @Token@ -> @GeoCommand@ [ctor] .
  op cut`point_and_of_and_ : @Token@ @Token@ @Token@ @Token@ -> @GeoCommand@ [ctor] .
  op cut`point`of_and_ : @Token@ @Token@ -> @GeoCommand@ [ctor] .

endfm

fmod META-GEO-SIGN is
 inc META-FULL-MAUDE-SIGN .
 inc UNIT .

 op GEO-GRAMMAR : -> FModule [memo] .
 eq GEO-GRAMMAR = addImports((including 'GEO-SIGNATURE .), GRAMMAR) .
endfm


fmod GEO-COMMAND-PROCESSING is
 pr COMMAND-PROCESSING .
 pr DICC-FIGURAS .
 pr GEO2D .

 vars T T' T'' NP NC NR : Term .
 vars Q Q' Q'' name1 name2 : Qid .
 vars S S' : String .
 vars F F' : Float .
 vars P1 P2 p1 p2 p3 : Punto .
 vars f1 f2 : Figura .
 vars 1entrada 2entrada : Entry .
 vars D Dp Dr Dc : Dic .

 op processPoint : Term Term -> Entry .
 eq processPoint('bubble[T], 'token[NP]) = downQid(NP) -> processPointAux(T) .

 op processPointAux : Term -> Punto .
 ceq processPointAux('__[T, T']) = qid2point(Q, Q')
  if Q := downQid(T) /\
     Q' := downQid(T') .

 op qid2point : Qid Qid -> Punto .
 ceq qid2point(Q, Q') = p(F F')
  if S := string(Q) /\
     S' := string(Q') /\
     F := float(S) /\
     F' := float(S') .

 op processCircumference-1 : Term Punto Term -> Entry .
 ceq processCircumference-1('token[NC] , P1 , 'bubble[T]) = downQid(NC) -> c(P1 , F)
  if Q := downQid(T)
  /\ S := string(Q)
  /\ F := float(S) 
  /\ not F == 0.0 .
 ceq processCircumference-1('token[NC] , P1 , 'bubble[T]) = downQid(NC) -> P1 
  if Q := downQid(T)
  /\ S := string(Q)
  /\ F := float(S) 
  /\ F == 0.0 .

 op processCircumference-2 : Term Term Punto Punto Punto -> Entry .
 ceq processCircumference-2('token[NC], 'token[NP], p1, p2, p3) = downQid(NC) -> c(p1, F)
  if F := distancia(p2, p3) 
  /\ not F == 0.0 .
 ceq processCircumference-2('token[NC], 'token[NP], p1, p2, p3) = downQid(NP) -> p1
  if F := distancia(p2, p3)
  /\ F == 0.0 .

 op processLine : Term Punto Punto -> Entry .
 eq processLine('token[NR] , P1 , P2) = downQid(NR) -> r(P1 P2) .

 op processCutPoint : Term Term Figura Figura -> Dic .
 ceq processCutPoint('token[T] , 'token[T'] , f1 , f2) = processCutPointAux(p1, p2, f1, f2, 1entrada,2entrada)
  if p1 := primer-elemento(pto-corte(f1 , f2))
  /\ p2 := primer-elemento(quitar-primer-elemento(pto-corte(f1 , f2)))
  /\ 1entrada := downQid(T) -> p1
  /\ 2entrada := downQid(T') -> p2 .

 op processCutPointAux : Punto Punto Figura Figura Entry Entry -> Dic .
 ceq processCutPointAux(p1, p2, f1, f2, 1entrada, 2entrada) = 1entrada . 2entrada
  if not p1 == p2
  /\ long-lista(pto-corte(f1 , f2)) == 2.0 .
 ceq processCutPointAux(p1, p2, f1, f2, 1entrada, 2entrada) = 1entrada
  if p1 == p2
  /\ long-lista(pto-corte(f1 , f2)) == 2.0 .
 ceq processCutPointAux(p1, p2, f1, f2, 1entrada, 2entrada) = 1entrada
  if long-lista(pto-corte(f1 , f2)) == 1.0 .
 ceq processCutPointAux(p1, p2, f1, f2, 1entrada, 2entrada) = mtD
  if long-lista(pto-corte(f1 , f2)) == 0.0 .

 op new-name : Qid Qid -> Qid .
 eq new-name(name1, name2) = qid(string(name1) + string(name2)) .

 op mod-elements : DicFiguras Dic -> QidList .
 eq mod-elements([Dp, Dr, Dc], D . Q -> f1) = mod-elements([Dp, Dr, Dc], D) nombre([Dp, Dr, Dc], f1) .
 eq mod-elements([Dp, Dr, Dc], mtD) = nil .

endfm

mod GEO-DATABASE-HANDLING is
 pr GEO-COMMAND-PROCESSING .
 inc DATABASE-HANDLING .
 pr DICC-FIGURAS .

 sort GEODatabaseClass .
 subsort GEODatabaseClass < DatabaseClass .

 var  MUDC : GEODatabaseClass .
 var  AtS : AttributeSet .
 var  DB : Database .
 vars T1 T2 T3 T4 : Term .
 var  F F' : Figura .
 var  O : Oid .
 var  D : DicFiguras .
 var  D' : Dic .
 var  D? : [Dic] .
 vars Q Q' name1 name2 : Qid .
 var names : QidList .

 op dic :_ : DicFiguras -> Attribute [ctor] .

 crl [point] :
     < O : MUDC | input : ('point_as_[T1 , T2]), dic : D,
                  output : nil, AtS >
  => < O : MUDC | input : nilTermList, dic : (D [Q / F]),
                  output : ('Punto 'almacenado Q) , AtS >
  if Q -> F := processPoint(T1 , T2) /\
     names := mod-elements(D [Q / F], Q -> F) .

 crl [circumference1] :
     < O : MUDC | input : ('circumference_in_with`radius_[T1 , 'token[T2] , T3]), dic : D,
                  output : nil, AtS >
  => < O : MUDC | input : nilTermList, dic : (D [Q / F]),
                  output : ('Circunferencia names) , AtS >
  if Q -> F := processCircumference-1(T1 , D[downQid(T2)] , T3) /\
     names := mod-elements(D [Q / F], Q -> F) .

 crl [circumference2] :
     < O : MUDC | input : ('circumference_in_with`radius`distance`from_to_[T1 , 'token[T2] , 'token[T3], 'token[T4]]), dic : D,
                  output : nil, AtS >
  => < O : MUDC | input : nilTermList, dic : (D [Q / F]),
                  output : ('Circunferencia names) , AtS >
  if Q -> F := processCircumference-2(T1, 'token[T2], D[downQid(T2)], D[downQid(T3)], D[downQid(T4)]) /\
     names := mod-elements(D [Q / F], Q -> F) .

 crl [circumference3] :
     < O : MUDC | input : ('circumference`in_with`radius`distance`from_to_['token[T1] , 'token[T2], 'token[T3]]), dic : D,
                  output : nil, AtS >
  => < O : MUDC | input : nilTermList, dic : (D [Q / F]),
                  output : ('Circunferencia names) , AtS >
  if name1 := new-name(downQid(T1), downQid(T2)) /\
     name2 := new-name(name1, downQid(T3)) /\
     Q -> F := processCircumference-2('token[upTerm(name2)], 'token[T1], D[downQid(T1)], D[downQid(T2)], D[downQid(T3)]) /\
     names := mod-elements(D [Q / F], Q -> F) .

 crl [line1] :
     < O : MUDC | input : ('line_from_to_[T1 , 'token[T2] , 'token[T3]]), dic : D,
                  output : nil, AtS >
  => < O : MUDC | input : nilTermList, dic : (D [Q / F]),
                  output : ('Recta 'almacenada names) , AtS >
  if Q -> F := processLine(T1 , D[downQid(T2)] , D[downQid(T3)]) /\
     names := mod-elements(D [Q / F], Q -> F) .

 crl [line2] :
     < O : MUDC | input : ('line`from_to_['token[T1] , 'token[T2]]), dic : D,
                  output : nil, AtS >
  => < O : MUDC | input : nilTermList, dic : (D [Q / F]),
                  output : ('Recta 'almacenada names) , AtS >
  if name1 := new-name(downQid(T1), downQid(T2)) /\
     Q -> F := processLine('token[upTerm(name1)], D[downQid(T1)] , D[downQid(T2)])  /\
     names := mod-elements(D [Q / F], Q -> F) . ***[print " sdfds "]

 crl [cut1] :
     < O : MUDC | input : ('cut`point_and_of_and_[T1, T2, 'token[T3], 'token[T4]]), dic : D,
                  output : nil, AtS >
  => < O : MUDC | input : nilTermList, dic : (D U [D' , mtD , mtD]),
                  output : ('Puntos 'almacenados names) , AtS >
  if D' := processCutPoint(T1 , T2 , D[downQid(T3)] , D[downQid(T4)]) /\
     names := mod-elements(D U [D' , mtD , mtD], D').


 crl [cut2] :
     < O : MUDC | input : ('cut`point`of_and_['token[T1], 'token[T2]]), dic : D,
                  output : nil, AtS >
  => < O : MUDC | input : nilTermList, dic : (D U [D' , mtD , mtD]),
                  output : ('Puntos 'almacenados names) , AtS >
  if Q := downQid(T1) /\
     Q' := downQid(T2) /\
     name1 := new-name(Q, Q') /\
     name2 := new-name(Q', Q) /\
     D' := processCutPoint('token[upTerm(name1)], 'token[upTerm(name2)], D[Q], D[Q']) /\
     names := mod-elements(D U [D' , mtD , mtD], D') .


endm

mod MUNIT is
 inc GEO-DATABASE-HANDLING .
 inc META-GEO-SIGN .
 inc LOOP-MODE .

 var  QI : Qid .
 vars QIL QIL' QIL'' : QidList .
 var  Atts : AttributeSet .
 var  N : Nat .
 var  DB : Database .
 vars RP RP' : ResultPair .
 var  O : Oid .
 var  X@Database : DatabaseClass .

 op o : -> Oid [ctor] .

 op GEODatabase : -> GEODatabaseClass [ctor] .

 --- State for LOOP mode:
 subsort Object < State .
 op init-geo : -> System .

 op init-state : -> AttributeSet .
 eq init-state = dic : [mtD, mtD, mtD], db : initialDatabase, default : 'CONVERSION .
 op geo-banner : -> QidList .
 eq geo-banner = '\n '\t 'GEO: 'GEO2D 'a 'unit 'testing 'framework 'for 'Maude.
           '\n '\t ' '\t '`( 'October '27th '`, '\s '2016 '`) '\n .

 rl [init] :
    init-geo
 => [nil, < o : GEODatabase | input : nilTermList, output : nil,
                              init-state >, geo-banner] .

 crl [in] :
     [QIL, < O : X@Database | input : nilTermList, Atts >, QIL']
  => [nil,
      < O : X@Database | input : getTerm(metaParse(GEO-GRAMMAR, QIL, '@Input@)), Atts >,
      QIL']
  if QIL =/= nil /\
     metaParse(GEO-GRAMMAR, QIL, '@Input@) : ResultPair .

 crl [in] :
     [QIL, < O : X@Database | output : nil, Atts >, QIL']
  => [nil,
      < O : X@Database | output : ('\r 'Warning: '\o
                printSyntaxError(metaParse(GEO-GRAMMAR, QIL, '@Input@), QIL)
                '\n
                '\r 'Error: '\o 'No 'parse 'for 'input. '\n), Atts >,
      QIL']
  if QIL =/= nil /\
     noParse(N) := metaParse(GEO-GRAMMAR, QIL, '@Input@)  .

 crl [in] :
     [QIL, < O : X@Database | output : nil, Atts >, QIL']
  => [nil,
      < O : X@Database | output :  ('\r 'Error: '\o 'Ambiguous 'input. '\n), Atts >,
      QIL']
   if QIL =/= nil /\
      ambiguity(RP, RP') := metaParse(GEO-GRAMMAR, QIL, '@Input@)  .

 rl [out] :
    [QIL, < O : X@Database | output : (QI QIL'), Atts >, QIL'']
 => [QIL, < O : X@Database | output : nil, Atts >, (QIL'' QI QIL')] .
endm

set print conceal on .
print conceal mod_is_sorts_._____endm .
print conceal fmod_is_sorts_.____endfm .
print conceal db .

*** for debugging purposes
set print attribute on .


loop init-geo .


(point 0.0 0.0 as p1)
(point 1.0 1.0 as p2)
(point 1.0 0.0 as p3)
(point 0.0 1.0 as p4)
(line r1 from p1 to p2)
(line from p3 to p4)
(circumference c1 in p1 with radius 1.0)
(circumference c2 in p2 with radius 1.0) 
(circumference c3 in p2 with radius distance from p3 to p4)
(circumference in p4 with radius distance from p1 to p2)
(cut point of c1 and c2)
(circumference zero in p1 with radius 0.0)
