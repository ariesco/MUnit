%!TEX root = tfg_fiesta.tex

\fixme{Ojo a las tildes en todo el trabajo}

Para ilustrar lo comentado en la introducción en este primer capitulo definiremos unos primeros módulos sencillos que nos serviran de ejemplo, y más adelante extenderemos con los test de unidad. \par
El primero de estos se corresponderá con los números naturales, los cuales ser\'an definidos de forma análoga al método de Peano. Posteriormente se le dará distintas operaciones sencillas como la suma, y al mismo tiempo algunas basadas en el orden.\par

\fixme{No es que se definan de manera análoga, sino que se definen siguiendo los axiomas de
Peano. Para las explicaciones pon más cosas. Por ejemplo, en el siguiente párrafo
tienes que dar explicaciones de qué son los módulos funcionales, algo del estilo: las teorías
ecuacionales se especifican en Maude mediante módulos funcionales, que empiezan con la palabra
reservada \texttt{fmod} seguida del nombre del módulo y de la palabra reservada \texttt{is}:}

Un módulo funcional en Maude empieza con la palabra reservada \texttt{fmod}. \par

{\codesize
\begin{verbatim}
fmod PEANO-NAT-EXTRA is
\end{verbatim}
}

Es posible definir tipos de datos mediante \texttt{sort}, y \texttt{sorts} en el caso en que sean varios. \par

{\codesize
\begin{verbatim}
   sorts Nat NoZeroNat ZeroNat .
\end{verbatim}
}

Dentro de los tipos se les puede dotar de orden\fixme{Explicar a qué te refieres con orden, si no se ha explicado antes}, ya que Maude es un lenguaje con orden. \par

{\codesize
\begin{verbatim}
   subsort NoZeroNat < Nat .
   subsort ZeroNat < Nat .
\end{verbatim}
}

Antes de utilizar un tipo suele ser necesario darle un constructor para poder trabajar con él. Para ello daremos un operador \texttt{op}, unos tipos a este, indicando la entrada y la salida, y por último indicaremos que es un constructor con \fixme{el atributo} \texttt{ctor}. \par

{\codesize
\begin{verbatim}
   op 0 : -> ZeroNat [ctor] .
   op s : Nat -> NoZeroNat [ctor iter] .
\end{verbatim}
}

Como se puede observar a los constructores, se les puede dotar de propiedades con algunos comandos como \texttt{iter}, que le permite tener una definición recursiva o iterativa.\fixme{La definición es puramente recursiva, iter lo que te permite es acortar los términos construidos con ese operador (s(s(s(0)))) vs s^3(0)}
 \par

Continuando con la creación del módulo, antes de definir ninguna función sera necesario hacer una declaración de variables en base a sus tipos mediante el comando \texttt{var}, o \texttt{vars} terminando con el tipo correspondiente.\fixme{Esto no es estrictamente cierto, se pueden definir variables on-the-fly o usar constantes} \par

{\codesize
\begin{verbatim}
   vars M N R : Nat .
\end{verbatim}
}

La creacion de la funciones comienza de forma similar a la de los constructores, con el comando \texttt{op}, y tambien va acompañado de los tipos, que indican la entrada y la salida de esta. Sin embargo tambien hay que dotar a la función de forma, esto se puede hacer simplemente indicando un nombre, o mediante una construcción del tipo \verb"_+_" donde \verb"_" indica la posición de los valores de entrada. quedando entonces como sigue:\fixme{Es sorprendente que la suma no sea conmutativa/asociativa} \par

{\codesize
\begin{verbatim}
   op add : Nat Nat -> Nat .                   op _+_ : Nat Nat -> Nat .
\end{verbatim}
}

Una vez definida la función habra que dotarla de ecuaciones para indicar su comportamiento\fixme{Más bien la dotas de comportamiento mediante ecuaciones, que aunque desde el punto de vista
ecuacional indican igualdades desde el punto de vista operacional se ejecutan de izquierda a
derecha}. Estas comenzaran por \texttt{eq} e indicaran mediante una igualdad el resultado de la operación. A la hora de dar las ecuaciones dependemos de la definición de la operación, siendo las ecuaciones del primer caso las de la izquierda, y las del segundo las de la derecha. \par
{\codesize
\begin{verbatim}
   eq add(0 , N) = N .                         eq 0 + N = N .
   eq add(s(M) , N) = s(add(M , N)) .          eq s(M) + N = s(M + N) .
\end{verbatim}
}

Por supuesto esta no es la unica forma que tenemos de dar las funciones, sino que en los casos de condicionales tendremos que usar el comando \texttt{ceq} asi como dar con \texttt{if} o \texttt{if not}\fixme{No existe if not como tal, lo que ocurre es que el if admite Booleanos y una expresión
Booleana puede tener not} las condiciones booleanas\fixme{Booleano es con mayúsculas} a las distintas ecuaciones. \par

{\codesize
\begin{verbatim}
   op _*_ : Nat Nat -> Nat .
   ceq M * N = 0 
   if M == 0.
   ceq s(M) * N = (M * N) + N
   if not (s(M) == 0) .
\end{verbatim}
}

Ejemplos de otras funciones pueden ser las dos siguientes, definidas de forma análoga a la suma.\fixme{como == está predefinido sería mejor cambiarlo por un solo =} \par

{\codesize
\begin{verbatim}
   op _==_ : Nat Nat -> Nat .                  op _<_ : Nat Nat -> Bool .
   eq 0 == s(M) = false .                      eq 0 < s(M) = true .
   eq 0 == 0 = true .                          eq 0 < 0 = false .
   eq s(M) == s(N) = M == N .                  eq s(M) < 0 = false .
                                               eq s(M) < s(N) = M < N .	

\end{verbatim}
}

Una vez hayamos creado e incluido todas las funciones sera necesario indicar la terminación del módulo mediante: \par

{\codesize
\begin{verbatim}
endfm
\end{verbatim}
}

Este pequeño módulo ilustra la sintaxis básica de Maude. De forma análoga definiremos uno paralelo para listas, que además hará uso del anterior. \par

{\codesize
\begin{verbatim}
fmod Lista is
\end{verbatim}
}
Al estar trabajando de nuevo con un módulo funcional este vuelve a empezar con \verb"fmod _ is", sin embargo como queremos utilizar los naturales debemos importarlos. Para importar un módulo tenemos tres opciones, \texttt{protecting}, \texttt{extending} y \texttt{including}, sin embargo en general utilizaremos \texttt{protecting}, de la forma \texttt{pr}, ya que nos importa los modulos pero no nos permite modificarlos, evitando así confusión y problemas de interacción con otros. \par

{\codesize
\begin{verbatim}
   pr PEANO-NAT-EXTRA .
\end{verbatim}
}

Ahora ya sí definimos el módulo comenzando por los tipos, las variables, y finalmente algunos operadores. \par

{\codesize
\begin{verbatim}
   sort Lista .
   subsorts Nat < Lista .
   vars M N  : Nat .
   vars L1 L2 : Lista .	

   op mt : -> Lista [ctor] .
   op __ : Lista Lista -> Lista [ctor assoc comm id: mt] .

endfm
\end{verbatim}
}

Una de las cosas que debe llamarnos la atención es \verb"[ctor assoc comm id: mt] ." pues ademas de indicar que \verb"__" es un constructor, \texttt{ctor}, nos da otra información vease, \texttt{assoc comm id: mt}. Las tres nos dan propiedades sobre el operador, asociatividad, commutatividad, pero el más importante seria el ultimo, que nos proporciona un elemento neutro para la operación, en este caso \texttt{mt}, que identificaremos como la lista vacia. \par

Por supuesto el módulo tal cual queda muy pobre, y no seria demasiado complicado completarlo con nuevas funciones como aquellas que nos indiquen si una lista es vacía o su longitud. Estas operaciones se dejan a continuación con huecos para que sean completadas.\fixme{Queda raro que los
tests y los huecos empiecen en el segundo ejemplo, yo pondría algo para el primero con explicaciones} \par

{\codesize
\begin{verbatim}
op empty-list : Lista -> Bool .                   op length-list : List -> *** .
*** Comprueba si una lista es la lista vacia.     *** Da la longitud de una lista.
eq empty-list(mt) = true .                        eq length-list(mt) = 0 .
eq empty-list(L M) = *** .                        eq length-list(L M) = s(length-list(L)) .
\end{verbatim}
}

Si bien todo lo anterior ha resultado util para comprender la sintaxis básica de Maude, en operaciones de mayor complejidad necesitaremos mayor información sobre estas, para lo que haremos uso de los test de unidad. Como ya se a comentado anteriormente para esto haremos uso del módulo \texttt{mUnit.maude}, que nos proporciona distintos casos segun lo que queramos comprobar.\par

Los test deben comenzar indicando el módulo sobre el que vamos a trabajar, en nuestro caso \texttt{PEANO-NAT-EXTRA}. \par

{\codesize
\begin{verbatim}
(munit PEANO-NAT-EXTRA is
\end{verbatim}
}

El primer caso de test con que nos encontraremos será \verb"assertEqual(_, _)", que evaluará las dos expresiones que recibe como datos y devolvera \texttt{true} en el caso de que seán iguales, o \texttt{false} en el caso de que o bien no evaluen a lo mismo, o una no se evalue correctamente. \par

{\codesize
\begin{verbatim}
   assertEqual(s(0) + s(0), s(s(0)))
\end{verbatim}
}

De forma opuesta nos encontramos con \verb"assertDifferent(_, _)", que evaluará a \texttt{true} si las expresiones evaluan a cosas distintas, o \texttt{false} en otro caso. \par

{\codesize
\begin{verbatim}
   assertDifferent(0, s(0))
\end{verbatim}
}

Sin embargo no todas las operaciones evaluan a una expresión, sino que es muy común que lo hagan a un booleano. Debido a esto utilizaremos tambien otras dos funciones, \verb"assertTrue(_)" y \verb"assertFalse(_)". Devolviendonos la primera \texttt{true} en caso de que evalue a \texttt{true} o \texttt{false} en otro caso. La segunda función se comporta al contrario, devolviendonos \texttt{true} si la expresión evalua a \texttt{false}, o \texttt{false} en caso contrario.\par

{\codesize
\begin{verbatim}
   assertTrue(0 < s(0))
   assertFalse(s(0) < 0)
\end{verbatim}
}

Finalmente los test se cierran con \texttt{endu}. \par

{\codesize
\begin{verbatim}
endu)
\end{verbatim}
}

Un ejemplo de test de unidad completo sería el siguiente: \par

{\codesize
\begin{verbatim}
(munit PEANO-NAT-EXTRA is
   assertEqual(s(0) + s(0), s(s(0)))
   assertEqual(0 + s(s(s(0))), s(s(s(0))))
   assertEqual(0 * s(0), 0)
   assertEqual(s(s(0)) * s(s(s(0))) ,s(s(s(s(s(s(0)))))))
   assertDifferent(0, s(0))
   assertTrue(0 < s(0))
   assertFalse(s(0) < 0)
   assertFalse(0 < 0)
   assertFalse(s(0) < 0)
   assertTrue(s(0) < s(s(0)))
   assertFalse(s(s(0)) < s(s(0)))
   assertFalse(s(0) == 0)
   assertTrue(0 == 0)
   assertFalse(s(0) == s(s(0)))
   assertTrue(s(s(0)) == s(s(0)))
endu)

\end{verbatim}
}

Es en la ejecución de estos test en los que vemos que todo funciona tal y como queremos, ya sea por que hemos terminado correctamente los módulos incompletos y estos funcionan tal y como deberían, o por que el test es debil y no cubre todos los casos. Veamos ahora un ejemplo de ejecución. \par

\begin{verbatim}
15 test cases were executed.

0 failures.

assertDifferent(0,s(0)) passed.
assertEqual(s(0)+ s(0),s(s(0))) passed.
assertEqual(0 + s(s(s(0))),s(s(s(0)))) passed.
assertEqual(0 * s(0),0) passed.
assertEqual(s(s(0))* s(s(s(0))),s(s(s(s(s(s(0))))))) passed.
assertTrue(0 < s(0)) passed.
assertFalse(s(0)< 0) passed.
assertFalse(0 < 0) passed.
assertFalse(s(0)< 0) passed.
assertTrue(s(0)< s(s(0))) passed.
assertFalse(s(s(0))< s(s(0))) passed.
assertFalse(s(0)== 0) passed.
assertTrue(0 == 0) passed.
assertFalse(s(0)== s(s(0))) passed.
assertTrue(s(s(0))== s(s(0))) passed.
\end{verbatim}

El test funciona correctamente, y cubre todos los casos, así que podemos dar por supuesto que el módulo es correcto. De manera analoga podemos crear un test para listas: \par

\begin{verbatim}
(munit Lista is
   assertEqual(mt, mt mt)
   assertEqual(s(0), mt s(0))
   assertEqual(s(0) s(s(0)), s(s(0)) s(0))
   assertTrue(empty-list(mt))
   assertFalse(empty-list(s(0)))
   assertEqual(length-list(mt), 0)
   assertEqual(length-list(s(s(0))), s(0))
   assertDifferent(length-list(s(s(0))), s(s(0)))
endu)
\end{verbatim}

Esto no solo sirve para ilustrar el buen funcionamiento de un programa, sino que ayuda a completar los huecos dejados anteriormente, mostrando el caso que habiamos dejado vacio en \texttt{empty-list} y el tipo de salida de \texttt{length-list}. \par

Y con esto cubrimos los primeros módulos funcionales en Maude, más adelanta hablaremos de los módulos en los que se puedan dar reglas, pero antes abordaremos uno funcional más complejo de lo visto aqui. Aun asi los módulos anteriores así como sus test de unidad se pueden encontrar aquí(hiper) en el apendice correspondiente.\par 


