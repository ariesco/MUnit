%!TEX root = tfg_fiesta.tex

Para ilustrar lo comentado en la introducción en este primer capitulo definiremos unos primeros módulos sencillos que nos serviran de ejemplo, y más adelante extenderemos con los test de unidad. \par
El primero de estos se corresponderá con los números naturales, los cuales ser\'an definidos de forma análoga al método de Peano. Posteriormente se le dará distintas operaciones sencillas como la suma, y al mismo tiempo algunas basadas en el órden.\par

Un módulo funcional en Maude empieza con la palabra reservada \texttt{fmod}...

{\codesize
\begin{verbatim}
fmod PEANO-NAT-EXTRA is
\end{verbatim}
}

Es posible definir tipos de datos mediante \texttt{sort}, y \texttt{sorts} en el caso en que sean varios.

{\codesize
\begin{verbatim}
   sorts Nat NoZeroNat ZeroNat .
\end{verbatim}
}

Dentro de los tipos se les puede dotar de órden, ya que Maude es un que permite el orden entre sus tipos. \par

{\codesize
\begin{verbatim}
   subsort NoZeroNat < Nat .
   subsort ZeroNat < Nat .
\end{verbatim}
}

Antes de utilizar un tipo suele ser necesario darle un constructor para poder trabajar con él. Para ello daremos un operador \texttt{op}, unos tipos a este, indicando la entrada y la salida, y por último indicaremos que es un constructor con \texttt{[ctor]}. \par

{\codesize
\begin{verbatim}
   op 0 : -> ZeroNat [ctor] .
   op s : Nat -> NoZeroNat [ctor iter] .
\end{verbatim}
}

Como se puede observar a los constructores, se les puede dotar de propiedades con algunos comandos como \texttt{iter}, que le permite tener una definición recursiva o iterativa. \\

Continuando con la creación del módulo, antes de definir ninguna función sera necesario hacer una declaración de variables en base a sus tipos mediante el comando \texttt{var}, o \texttt{vars} terminando con el tipo correspondiente. 

{\codesize
\begin{verbatim}
   vars M N R : Nat .
\end{verbatim}
}

La creacion de la funciones comienza de forma similar a la de los constructores, con el comando \texttt{op}, y tambien va acompañado de los tipos, que indican la entrada y la salida de esta. Sin embargo tambien hay que dotar a la función de forma, esto se puede hacer simplemente indicando un nombre, o mediante una construcción del tipo \verb"_+_" donde \verb"_" indica la posición de los valores de entrada. quedando entonces como sigue: \par

{\codesize
\begin{verbatim}
   op add : Nat Nat -> Nat .                   op _+_ : Nat Nat -> Nat .
\end{verbatim}
}

Una vez definida la función habra que dotarla de ecuaciones para indicar su comportamiento. Estas comenzaran por \texttt{eq} e indicaran mediante una igualdad el resultado de la operación. A la hora de dar las ecuaciones dependemos de la definición de la operación, siendo las ecuaciones del primer caso las de la izquierda, y las del segundo las de la derecha. \par
{\codesize
\begin{verbatim}
   eq add(0 , N) = N .                         eq 0 + N = N .
   eq add(s(M) , N) = s(add(M , N)) .          eq s(M) + N = s(M + N) .
\end{verbatim}
}

Por supuesto esta no es la unica forma que tenemos de dar las funciones, sino que en los casos de condicionales tendremos que usar el comando \texttt{ceq} asi como dar con \texttt{if} o \texttt{if not} las condiciones booleanas a las distintas ecuaciones. \par

{\codesize
\begin{verbatim}
   op _*_ : Nat Nat -> Nat .
   ceq M * N = 0 
   if M == 0.
   ceq s(M) * N = (M * N) + N
   if not (s(M) == 0) .
\end{verbatim}
}

Ejemplos de otras funciones pueden ser las dos siguientes, definidas de forma análoga a la suma. \par

{\codesize
\begin{verbatim}
   op _==_ : Nat Nat -> Nat .                  op _<_ : Nat Nat -> Bool .
   eq 0 == s(M) = false .                      eq 0 < s(M) = true .
   eq 0 == 0 = true .                          eq 0 < 0 = false .
   eq s(M) == s(N) = M == N .                  eq s(M) < 0 = false .
                                               eq s(M) < s(N) = M < N .	

\end{verbatim}
}

Una vez hayamos creado e incluido todas las funciones sera necesario indicar la terminación del módulo mediante: \par

{\codesize
\begin{verbatim}
endfm
\end{verbatim}
}

Este pequeño m\'odulo ilustra la sintaxis b\'asica de Maude. De forma an\'aloga definimos uno paralelo para listas, que adem\'as har\'a uso del anterior. 

\begin{verbatim}
fmod Lista is
   pr FLOAT .
   sort Lista .
   subsorts Float < Lista .
	
   op mt : -> Lista [ctor] .
   op __ : Lista Lista -> Lista [ctor assoc comm id: mt] .

endfm
\end{verbatim}

Para comprobar el comportamiento de estos dos m\'odulos realizaremos sendos test de unidad, que, como ya se ha comentado, comprobaran todas las opciones posibles de ejecuci\'on en cada programa. \par

\begin{verbatim}
load PEANO-NAT-EXTRA.maude
load ../mUnit.maude

(munit PEANO-NAT-EXTRA is

   assertDifferent(0, s(0))
   assertEqual(s(0) + s(0), s(s(0)))
   assertEqual(0 + s(s(s(0))), s(s(s(0))))
   assertEqual(0 * s(0), 0)
   assertEqual(s(s(0)) * s(s(s(0))) ,s(s(s(s(s(s(0)))))))

   assertTrue(0 < s(0))
   assertFalse(s(0) < 0)
   assertFalse(0 < 0)
   assertFalse(s(0) < 0)
   assertTrue(s(0) < s(s(0)))
   assertFalse(s(s(0)) < s(s(0)))
   
   assertFalse(s(0) == 0)
   assertTrue(0 == 0)
   assertFalse(s(0) == s(s(0)))
   assertTrue(s(s(0)) == s(s(0)))
   
endu)
\end{verbatim}

Aun as\' i el m\'odulo en este estado no nos proporciona ninguna informaci\'on, sino que deberemos ir a su ejecuci\'on para comprobar que todo ha ido tal y como quer\'iamos. \par

\begin{verbatim}
	MUnit: a unit testing framework for Maude.
		Version 1.0(November 23rd, 2016)


15 test cases were executed.

0 failures.

assertDifferent(0,s(0)) passed.
assertEqual(s(0)+ s(0),s(s(0))) passed.
assertEqual(0 + s(s(s(0))),s(s(s(0)))) passed.
assertEqual(0 * s(0),0) passed.
assertEqual(s(s(0))* s(s(s(0))),s(s(s(s(s(s(0))))))) passed.
assertTrue(0 < s(0)) passed.
assertFalse(s(0)< 0) passed.
assertFalse(0 < 0) passed.
assertFalse(s(0)< 0) passed.
assertTrue(s(0)< s(s(0))) passed.
assertFalse(s(s(0))< s(s(0))) passed.
assertFalse(s(0)== 0) passed.
assertTrue(0 == 0) passed.
assertFalse(s(0)== s(s(0))) passed.
assertTrue(s(s(0))== s(s(0))) passed.
\end{verbatim}

Ahora ya si vemos que el test funciona correctamente, que es precisamente lo que quer\'iamos. De la misma manera realizamos el test para las listas y comprobamos su ejecuci\'on. \par

\begin{verbatim}
load Lista.maude
load ../mUnit.maude

(munit Lista is
   assertEqual(mt, mt mt)
   assertEqual(1.0, mt 1.0)
   assertEqual(1.0 2.0, 2.0 1.0)

endu)

\end{verbatim}

\begin{verbatim}
   Aqui ejecucion del test de listas.
\end{verbatim}

Por supuestos estos primeros m\'odulos mostrados son tremendamente sencillos, y mientras el de las listas permanecer\'a as\'i por comodidad, sera extendido en un cap\'tulo posterior, el referente a los n\'umeros naturales se completa c\'omodamente incluyendo el resto de operaciones b\'asicas como la divisi\'on entera restringida a los naturales, y una pseudo resta que solo funciona cuando al mayor le restas el menor. Sin embargo, los numeros naturales no son suficientes para resolver la mayoria de los problemas que nos encontramos, as\'i pues decidimos construir un modulo mayor llamado peano-int, que genera los enteros a partir de naturales dotandoles de signo. Por supuesto este no es el unico cambio a realizar, sino que debemos construir una nueva resta en los naturales, que dado cualquier par de numeros nos de el resultado del mayor menos el menor, y que ya en Peano-Int le doten de signo segun los valores iniciales. \\

Siguiendo el mismo camino extendemos los enteros con los racionales, incluyendo algunas funciones nuevas como el maximo comun divisor y el resto en los m\'dulos antiguos, ya que son operaciones que pueden vivir en los entornos anteriores, aunque sea con restricciones. Los modulos completos son Peano-Nat-Extra, Peano-Int-Extra y Peano-Rac-extra; sus modulos de test son test-Peano-Nat-Extra, test-Peano-Int-Extra y test-Peano-Rac-extra y las ejecuciones de estos ejec-Peano-Nat-Extra, ejec-Peano-Int-Extra y ejec-Peano-Rac-extra \par


