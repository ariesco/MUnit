%!TEX root = tfg_fiesta.tex

Al ser Maude un lenguaje algebraíco la mayoría de módulos, ejemplos y ejercicios que se pueden encontrar tienen que ver con esta caracteristica, siendo principalmente anillos y grupos. Debido a esto he intentado salirme de lo normal implementando el equivalente a la geometría con regla y compas, lo cual por supuesto tiene mucho que ver con el álgebra, pero no se recurre a los modelos anteriores. \par

Para la implementación de la idea partiremos por la división del modulo en tres, consistiendo el primero en la geometría básica en dos dimensiones con puntos, rectas y circunferencias, así como todas las interacciones entre ellas, el tercero consistirá en reglas para la entrada y la salida de datos, haciendo que sea interactivo y que para utilizarlo no sean necesarios conocimientos previos del lenguaje, solo el nombre de las reglas, o comandos, que utilizaremos. El segundo sería, al contrario que los otros dos, un módulo puente, que cargará con el peso de todas las funciones necesarias para la implementación del tercero pero que, por orden y claridad, no se incluirán en el módulo de geometría dado que ahí no serán necesarias. \par

Comencemos con la creación del primer módulo, como consta de tres objetos bien diferenciados lo dividiremos en tres fmod distintos, correspondiendo estos con los puntos, las rectas, y las circumferencias. La definición de los puntos sera sencilla, construyéndose como un par consistente por dos números reales, igual que se haría en papel. Por otro lado, a los puntos no se les puede dotar de operaciones complicadas, más allá del cálculo de la distancia entre dos de ellos y el intercambio de sus coordenadas. Asi pues el fmod, quedaria como sigue.
{\codesize
\begin{verbatim}
fmod POINT is

   pr FLOAT .
   sorts Point .

   op p(__) : Float Float -> Point [ctor] .
   *** Define un punto como un par de numeros reales

   vars z11 z12 z21 z22 : Float .

   op distance : Point Point -> Float .
   *** Calcula la distancia entre dos puntos mediante la metrica usual.
   eq distance(p(z11 z12) , p(z21 z22)) = sqrt(((z21 - z11) ^ 2.0) + ((z22 - z12) ^ 2.0)) .

   op trans-point : Point -> Point .
   *** Intercambia las coordenadas de un punto
   eq trans-point(p(z11 z12)) = p(z12 z11) .

endfm
\end{verbatim}
}
Como el módulo queda tan sencillo, y sera necesario importarlo para la creación de los otros dos, lo utilizaremos tambien para las funciones auxiliares que vayamos necesitando en los siguientes, como por ejemplo la implementación de las ecuaciones de segundo grado, lo que se verá a su tiempo. Siguiendo con el espíritu anterior el fmod contará con casos de test, que serán los que en este caso se encuentren incompletos y sera necesario rellenarlos. \par

{\codesize
\begin{verbatim}
(munit POINT is
*** Funcion distance.
assertEqual(distance(p(1.0 0.0), p(0.0 1.0)), ***)
assertEqual(distance(p(0.0 0.0), p(4.0 3.0)), ***)
assertEqual(distance(p(1.0 0.0), p(2.0 0.0)), ***)
assertEqual(distance(p(1.0 1.0), p(1.0 3.0)), ***)
*** Funcion pto-trans.
assert***(trans-point(p(1.0 0.0)), p(1.0 0.0))
assertEqual(trans-point(p(1.0 0.0)), ***)
endu)
\end{verbatim}
}

Por supuesto tanto el módulo como el test completos podrán encontrarse en el apendice correspondiente.\par

Dando por finalizada la creación del \texttt{fmod POINT}, comenzaremos con el de las rectas. Estas se implementarán de forma análoga a los puntos, pero en este caso como un par de estos. Como estamos intentando seguir un camino similar al de la geometría básica, inplementaremos además de las rectas el tipo vector, que se utilizará en varias operaciones de las primeras. Estos se construirán de nuevo como un par, que será el correspondiente a extremo menos origen de los puntos que las definen. Ahora ya sí comencemos con la definición de los tipos.\par 

{\codesize
\begin{verbatim}
fmod LINE is 

   pr POINT .
   sorts Line Vector .

   op r(__) : Point Point -> Line [ctor] .
   *** Define una recta como un par de puntos, mas adelante la daremos ecuaciones.
   op v(__) : Float Float -> Vector [ctor] .
   *** Define un vector como un par de reales.
   *** Extremo menos origen.

   vars p1 p2 p3 p4 : Point .
   vars z11 z12 z21 z22 z31 z32 z41 z42 m n : Float .
   vars r1 r2 : Line .
   vars v1 v2 : Vector .
   vars t : Bool .
\end{verbatim}
}

Las primeras funciones que crearemos para los vectores servirán para obtener información de ellos o la construcción de otros. Estas se corresponden con \texttt{v-scalar-prod}, que nos devuelve el producto escalar de dos vectores, \texttt{v-norm}, que nos da la norma de un vector, \texttt{perpendicular-vector}, que nos proporciona un vector perpendicular a uno dado, y finalmente \texttt{v-are-perpendicular?}, que nos dice si dos vectores son perpendiculares. Todas estas funciones son sencillas, y practicamente una copia de sus definiciones, motivo por el que no se incluyen aquí. Lo que sí que se mostrará es su test de unidad, logicamente ejecutado sobre el módulo completo.\par

{\codesize
\begin{verbatim}
(munit LINE is
      ***Función v-scalar-prod.
   assertEqual(v-scalar-prod(v(1.0 0.0), v(0.0 1.0)), 0.0)
   assertDifferent(v-scalar-prod(v(1.0 0.0), v(0.0 1.0)), 1.0)
   assertEqual(v-scalar-prod(v(1.0 2.0), v(2.0 1.0)), 4.0)
   assertEqual(v-scalar-prod(v(1.0 2.0), v(-2.0 1.0)), 0.0)		
      ***Funcion v-norm.
   assertDifferent(v-norm(v(2.0 0.0)), sqrt(8.0))
   assertDifferent(v-norm(v(2.0 0.0)), 4.0)
   assertEqual(v-norm(v(2.0 0.0)), 2.0)
   assertEqual(v-norm(v(2.0 3.0)), sqrt(13.0))
   assertEqual(v-norm(v(-2.0 3.0)), sqrt(13.0))
      ***Funcion perpendicular-vector.
   assertDifferent(perpendicular-vector(v(1.0 0.0)), v(0.0 1.0))
   assertDifferent(perpendicular-vector(v(1.0 2.0)), v(2.0 1.0))
   assertDifferent(perpendicular-vector(v(1.0 2.0)), v(-2.0 1.0))
   assertEqual(perpendicular-vector(v(1.0 0.0)), v(0.0 -1.0))
      ***Funcion v-are-perpendicular?.
   assertTrue(v-are-perpendicular?(v(1.0 0.0), v(0.0 1.0)))
   assertTrue(v-are-perpendicular?(v(1.0 0.0), v(0.0 -1.0)))
   assertFalse(v-are-perpendicular?(v(1.0 2.0), v(2.0 1.0)))
   assertTrue(v-are-perpendicular?(v(1.0 2.0), v(-2.0 1.0)))
   assertTrue(v-are-perpendicular?(v(2.0 3.0), perpendicular-vector(v(2.0 3.0))))
   assertTrue(v-are-perpendicular?(v(-72.0 96.0), perpendicular-vector(v(-72.0 96.0))))

endu)
\end{verbatim}
}

Antes de continuar con las operaciones para rectas construiremos dos funciones opuestas, \texttt{direction-vector-line} que nos devuelve el vector director de una recta, y \texttt{line-from-vector}, que recibe un vector, un punto y devuelde una recta. \par
{\codesize
\begin{verbatim}
   op direction-vector-line : Line -> Vector .
   *** Devuelve el vector director de una recta
   eq direction-vector-line(r(p(z11 z12) p(z21 z22))) = v((z21 - z11) (z22 - z12)) .

   op line-from-vector : Vector Point -> Line .
   *** Construye una recta mediante un vector y un punto dados.
   eq line-from-vector(v(z11 z12) , p(z21 z22)) = r(p(z21 z22) p((z11 + z21) (z12 + z22))) .
\end{verbatim}
}

Estas funciones nos ayudaran a a comprobar si dos rectas son perpendiculares o a calcular una perpendicular a otra en función a un punto dado, ya que simplemente convertiremos las rectas a vectores, y con las funciones anteriores se realizará todo el proceso para después simplemente devolverlas a rectas. Estas funciones son \texttt{perpendicular-line} y \texttt{are-perpendiculars} respectivamente. Volviendo a la idea original del módulo total, conseguir la geometría suficiente para imitar las construcciones con regla y compás, lo que necesitamos es hallar el punto de corte entre dos rectas. Para esto pondremos las ecuaciones en su forma implicita y resolveremos el sistema correspondiente. Comencemos entonces por encontrar los valores m y n, pendiente y desplazamiento, de las rectas. \par

{\codesize
\begin{verbatim}
   op equ-line-m : Line -> Float .
   *** Dados los dos puntos que definen la recta, devuelve el valor de m, 
   *** para poder "construirla" de forma y = mx + n.
   eq equ-line-m(r(p(z11 z12) p(z21 z22))) = (z22 - z12)/(z21 - z11) .

   op equ-line-n : Line -> Float .
   *** Dados los dos puntos que definen la recta, devuelve el valor de n, 
   *** para poder "construirla" de forma y = mx + n , teniendo cuidado 
   *** en las que son de la forma  x = n
   eq equ-line-n(r(p(z11 z12) p(z21 z22)))= z12 - 
      (z11 * equ-line-m(r(p(z11 z12) p(z21 z22)))) .

   op are-equal : Line Line -> Bool .
   *** comprueba si dos rectas son iguales a partir de m y n, pendiente y desplazamiento, 
   *** pues una recta puede construirse mediante infinitos pares de puntos.
   eq are-equal(r(p(z11 z12) p(z11 z22)), r(p(z11 z32) p(z11 z42))) = true . 
   eq are-equal(r1 , r2) = (equ-line-m(r1) == equ-line-m(r2)) and 
      (equ-line-n(r1) == equ-line-n(r2)) [owise] .
\end{verbatim}
}

Como se puede ver, ademas de las funciones antes mencionadas se ha incluido una más llamada \texttt{are-equal}, y es que no es dificil ver que la igualdad básica, \verb"_==_", en estos casos falla pues la misma recta puede estar definida de infinitas maneras distintas, vease: \texttt{r(p(0.0 0.0) p(1.0 1.0))} y \texttt{r(p(0.0 0.0) p(n n))} son la misma recta para todo n natural, pero no son identicamente iguales, que es lo que Maude pide, así que para él son distintas. Antes de definir los puntos de corte de dos rectas necesitaremos dos funciones básicas para la distinción de casos, \texttt{horizontal} y \texttt{vertical} que nos indicaran respectivamente si la recta que les demos es horizontal o vertical. Como ya sucedio más arriba la definición de estas funciones es practicamente trivial, simplemente comprobamos las coordenadas de los puntos, así que no se incluiran aquí. Aprovechando estas funciones construiremos la última función menor, \texttt{are-in-line} que comprueba si un punto pertenece a una recta comprobando la distancia del punto dado con los dos que definen la definen, si la suma de las distancias del punto dado a los originales es igual que la distancia entre estos el punto estará contenido en la recta. Esta función tampoco aparecera aquí por los motivos antes mencionados, su ecuación es practicamente trivial, consistiendo en una transcripción de lo que acabo de contar.\par

{\codesize
\begin{verbatim}

Hasta aquí versión revisada.

(munit LINE is
      ***Funciones referidas a las rectas.
      ***Funcion direction-vector-line
   assertEqual(direction-vector-line(r(p(0.0 0.0) p(1.0 1.0))), v(1.0 1.0))	
   assertDifferent(direction-vector-line(r(p(2.0 3.0) p(1.0 1.0))), v(1.0 2.0))
      ***Funcion line-from-vector.
   assertEqual(line-from-vector(v(1.0 2.0), p(0.0 0.0)),r(p(0.0 0.0) p(1.0 2.0)))
   assertDifferent(line-from-vector(v(1.0 2.0), p(0.0 0.0)),r(p(1.0 2.0) p(0.0 0.0)))
   assertTrue(are-equal(line-from-vector(v(1.0 2.0), p(0.0 0.0)), r(p(0.0 0.0) p(1.0 2.0))))
   assertTrue(are-equal(line-from-vector(v(1.0 2.0), p(0.0 0.0)), r(p(1.0 2.0) p(0.0 0.0))))
   assertTrue(are-equal(line-from-vector(v(2.0 3.0), p(1.0 1.0)), r(p(-1.0 -2.0) p(1.0 1.0))))
      ***Funcion perpendicular-line.
   assertTrue(are-equal(perpendicular-line(r(p(0.0 0.0) p(0.0 1.0)), p(0.0 0.0)), r(p(0.0 0.0) p(1.0 0.0))))
   assertTrue(are-equal(perpendicular-line(r(p(0.0 0.0) p(0.0 1.0)), p(1.0 1.0)), r(p(1.0 1.0) p(2.0 1.0))))
   assertTrue(are-equal(perpendicular-line(r(p(0.0 0.0) p(1.0 0.0)), p(0.0 0.0)), r(p(0.0 0.0) p(0.0 1.0))))
   assertTrue(are-equal(perpendicular-line(r(p(0.0 0.0) p(1.0 0.0)), p(1.0 1.0)), r(p(1.0 1.0) p(1.0 2.0))))
   assertFalse(are-equal(perpendicular-line(r(p(3.0 -6.0) p(9.0 74.0)), p(0.0 0.0)), r(p(0.0 0.0) p(1.0 -4.0))))
   assertTrue(are-equal(perpendicular-line(r(p(1.0 0.0) p(0.0 1.0)), p(0.5 0.5)), r(p(0.5 0.5) p(1.0 1.0))))
      ***Funcion are-perpendiculars.
   assertTrue(are-perpendiculars(r(p(0.0 0.0) p(0.0 1.0)), r(p(0.0 0.0) p(1.0 0.0))))
   assertTrue(are-perpendiculars(r(p(0.0 0.0) p(0.0 1.0)), r(p(1.0 1.0) p(2.0 1.0))))
   assertTrue(are-perpendiculars(r(p(0.0 0.0) p(1.0 0.0)), r(p(0.0 0.0) p(0.0 1.0))))
   assertFalse(are-perpendiculars(r(p(0.0 0.0) p(1.0 1.0)), r(p(1.0 1.0) p(1.0 2.0))))
   assertFalse(are-perpendiculars(r(p(3.0 -6.0) p(9.0 74.0)), r(p(0.0 0.0) p(1.0 -4.0))))
   assertFalse(are-perpendiculars(r(p(1.0 0.0) p(0.0 1.0)), r(p(1.5 0.5) p(1.0 1.0))))
      ***Funciones equ-line-m y equ-line-n.
   assertEqual(equ-line-m(r(p(0.0 0.0) p(1.0 1.0))), 1.0)
   assertEqual(equ-line-m(r(p(0.0 1.0) p(1.0 0.0))), -1.0)
   assertDifferent(equ-line-m(r(p(0.0 0.0) p(0.0 45.0))), 1.0)
   assertEqual(equ-line-n(r(p(0.0 0.0) p(1.0 1.0))), 0.0)
   assertEqual(equ-line-n(r(p(1.0 1.0) p(2.0 0.0))), 2.0)
   assertEqual(equ-line-n(r(p(45.0 0.0) p(0.0 45.0))), 45.0)
      ***Funcion are-equal.
   assertTrue(are-equal(r(p(0.0 0.0) p(1.0 1.0)) , r(p(23.0 23.0) p(-1.0 -1.0))))
   assertFalse(are-equal(r(p(0.0 0.0) p(1.0 0.0)) , r(p(0.0 0.0) p(0.0 1.0))))
   assertTrue(are-equal(r(p(0.0 1.0) p(0.0 2.0)), r(p(0.0 3.0) p(0.0 4.0))))
   assertFalse(are-equal(r(p(0.0 2.0) p(0.0 3.0)), r(p(1.0 2.0) p(1.0 3.0))))
      ***Funciones vertical y horizontal.
   assertTrue(vertical(r(p(13.0 -43.0) p(13.0 56.0))))
   assertFalse(vertical(r(p(13.0 -43.0) p(-13.0 56.0))))
   assertTrue(horizontal(r(p(57.0 12.0) p(24.0 12.0))))
   assertFalse(horizontal(r(p(57.0 12.0) p(24.0 -12.0))))
      ***Funcion are-in-line.
   assertTrue(are-in-line(p(0.0 0.0), r(p(0.0 0.0) p(1.0 1.0))))
   assertTrue(are-in-line(p(1.0 1.0), r(p(0.0 0.0) p(1.0 1.0))))
   assertTrue(are-in-line(p(0.5 0.5), r(p(0.0 0.0) p(1.0 1.0))))
   assertFalse(are-in-line(p(0.0 0.0), r(p(1.0 0.0) p(0.0 1.0))))
   assertFalse(are-in-line(p(2.0 3.0), r(p(2.0 1.0) p(4.0 3.0))))
   assertFalse(are-in-line(p(1.0 2.0), r(p(2.0 1.0) p(4.0 3.0))))
endu)
\end{verbatim}
}


Llegamos por fín a la parte que más nos interesaba de este fmod, hallar los puntos de corte.
Por comodidad lo primero que hacemos sera crear una función que nos indicara si dos rectas se cortan.
Posteriormente creamos otra que nos devuelve ese punto. en caso de que las rectas no se corten devolvera error de algun tipo, pero eso sera algo que se arreglar\'a m\'as adelante. 

\begin{verbatim}	

   op cut?-r-r : Line Line -> Bool .
   *** comprueba si dos rectas se cortan a partir de la pendiente de estas
   *** devolviendo el valor false si son paralelas y true en caso contrario.
   *** El caso en que sean coincidentes debera verse de forma manual comparandolas.
   ceq cut?-r-r(r1, r2) = true 
   if vertical(r1) and horizontal(r2) .
   ceq cut?-r-r(r1, r2) = true 
   if vertical(r2) and horizontal(r1) .
   eq cut?-r-r(r1, r2) = not (equ-line-m(r1) == equ-line-m(r2)) .

   op cut-point-r-r : Line Line -> Point .
   *** Devuelve el punto de corte de dos rectas dadas.
   ceq cut-point-r-r(r1, r2) = cut-point-r-r(r2, r1)
   if vertical(r1) .
   ceq cut-point-r-r(r1, r2) = cut-point-r-r(r2, r1)
   if horizontal(r2) .
   ceq cut-point-r-r(r1, r2) = p(x y)
   if x := cut-point-x(r1, r2) /\
      y := cut-point-y(r1, r2) .

   op cut-point-x : Line Line -> Float .
   *** Devuelve la coordenada X del punto de corte de las dos rectas.
   ceq cut-point-x(r1, r2) = (n2 - n1) / (m1 - m2)
   if not vertical(r2) /\
      m1 := equ-line-m(r1) /\
      m2 := equ-line-m(r2) /\
      n1 := equ-line-n(r1) /\
      n2 := equ-line-n(r2) .
   eq cut-point-x(r1, r(p(z11 z12) p(z11 z22))) = z11 .
	
   op cut-point-y : Line Line -> Float .
   *** Devuelve la coordenada Y del punto de corte de las dos rectas.
   ceq cut-point-y(r1, r2) = m1 * x + n1
   if not horizontal(r1) /\
      m1 := equ-line-m(r1) /\
      n1 := equ-line-n(r1) /\
      x := cut-point-x(r1, r2) .
   eq cut-point-y(r(p(z11 z12) p(z21 z12)), r2) = z12 .

endfm

\end{verbatim}

Veamos ahora que todo funciona como queremos, para ello construimos el test de unidad correspondiente.


\begin{verbatim}
load GEO2D.maude
load ../mUnit.maude

(munit LINE is
      ***Funciones referidas a las rectas.
      ***Funcion direction-vector-line
   assertEqual(direction-vector-line(r(p(0.0 0.0) p(1.0 1.0))), v(1.0 1.0))	
   assertDifferent(direction-vector-line(r(p(2.0 3.0) p(1.0 1.0))), v(1.0 2.0))
      ***Funciones equ-line-m y equ-line-n.
   assertEqual(equ-line-m(r(p(0.0 0.0) p(1.0 1.0))), 1.0)
   assertEqual(equ-line-m(r(p(0.0 1.0) p(1.0 0.0))), -1.0)
   assertDifferent(equ-line-m(r(p(0.0 0.0) p(0.0 45.0))), 1.0)
   assertEqual(equ-line-n(r(p(0.0 0.0) p(1.0 1.0))), 0.0)
   assertEqual(equ-line-n(r(p(1.0 1.0) p(2.0 0.0))), 2.0)
   assertEqual(equ-line-n(r(p(45.0 0.0) p(0.0 45.0))), 45.0)
      ***Funcion are-equal.
   assertTrue(are-equal(r(p(0.0 0.0) p(1.0 1.0)) , r(p(23.0 23.0) p(-1.0 -1.0))))
   assertFalse(are-equal(r(p(0.0 0.0) p(1.0 0.0)) , r(p(0.0 0.0) p(0.0 1.0))))
   assertTrue(are-equal(r(p(0.0 1.0) p(0.0 2.0)), r(p(0.0 3.0) p(0.0 4.0))))
   assertFalse(are-equal(r(p(0.0 2.0) p(0.0 3.0)), r(p(1.0 2.0) p(1.0 3.0))))
      ***Funcion line-from-vector.
   assertEqual(line-from-vector(v(1.0 2.0), p(0.0 0.0)),r(p(0.0 0.0) p(1.0 2.0)))
   assertDifferent(line-from-vector(v(1.0 2.0), p(0.0 0.0)),r(p(1.0 2.0) p(0.0 0.0)))
   assertTrue(are-equal(line-from-vector(v(1.0 2.0), p(0.0 0.0)), r(p(0.0 0.0) p(1.0 2.0))))
   assertTrue(are-equal(line-from-vector(v(1.0 2.0), p(0.0 0.0)), r(p(1.0 2.0) p(0.0 0.0))))
   assertTrue(are-equal(line-from-vector(v(2.0 3.0), p(1.0 1.0)), r(p(-1.0 -2.0) p(1.0 1.0))))
      ***Funcion perpendicular-line.
   assertTrue(are-equal(perpendicular-line(r(p(0.0 0.0) p(0.0 1.0)), p(0.0 0.0)), r(p(0.0 0.0) p(1.0 0.0))))
   assertTrue(are-equal(perpendicular-line(r(p(0.0 0.0) p(0.0 1.0)), p(1.0 1.0)), r(p(1.0 1.0) p(2.0 1.0))))
   assertTrue(are-equal(perpendicular-line(r(p(0.0 0.0) p(1.0 0.0)), p(0.0 0.0)), r(p(0.0 0.0) p(0.0 1.0))))
   assertTrue(are-equal(perpendicular-line(r(p(0.0 0.0) p(1.0 0.0)), p(1.0 1.0)), r(p(1.0 1.0) p(1.0 2.0))))
   assertFalse(are-equal(perpendicular-line(r(p(3.0 -6.0) p(9.0 74.0)), p(0.0 0.0)), r(p(0.0 0.0) p(1.0 -4.0))))
   assertTrue(are-equal(perpendicular-line(r(p(1.0 0.0) p(0.0 1.0)), p(0.5 0.5)), r(p(0.5 0.5) p(1.0 1.0))))
      ***Funcion are-perpendiculars.
   assertTrue(are-perpendiculars(r(p(0.0 0.0) p(0.0 1.0)), r(p(0.0 0.0) p(1.0 0.0))))
   assertTrue(are-perpendiculars(r(p(0.0 0.0) p(0.0 1.0)), r(p(1.0 1.0) p(2.0 1.0))))
   assertTrue(are-perpendiculars(r(p(0.0 0.0) p(1.0 0.0)), r(p(0.0 0.0) p(0.0 1.0))))
   assertFalse(are-perpendiculars(r(p(0.0 0.0) p(1.0 1.0)), r(p(1.0 1.0) p(1.0 2.0))))
   assertFalse(are-perpendiculars(r(p(3.0 -6.0) p(9.0 74.0)), r(p(0.0 0.0) p(1.0 -4.0))))
   assertFalse(are-perpendiculars(r(p(1.0 0.0) p(0.0 1.0)), r(p(1.5 0.5) p(1.0 1.0))))
      ***Funciones vertical y horizontal.
   assertTrue(vertical(r(p(13.0 -43.0) p(13.0 56.0))))
   assertFalse(vertical(r(p(13.0 -43.0) p(-13.0 56.0))))
   assertTrue(horizontal(r(p(57.0 12.0) p(24.0 12.0))))
   assertFalse(horizontal(r(p(57.0 12.0) p(24.0 -12.0))))
      ***Funcion are-in-line.
   assertTrue(are-in-line(p(0.0 0.0), r(p(0.0 0.0) p(1.0 1.0))))
   assertTrue(are-in-line(p(1.0 1.0), r(p(0.0 0.0) p(1.0 1.0))))
   assertTrue(are-in-line(p(0.5 0.5), r(p(0.0 0.0) p(1.0 1.0))))
   assertFalse(are-in-line(p(0.0 0.0), r(p(1.0 0.0) p(0.0 1.0))))
   assertFalse(are-in-line(p(2.0 3.0), r(p(2.0 1.0) p(4.0 3.0))))
   assertFalse(are-in-line(p(1.0 2.0), r(p(2.0 1.0) p(4.0 3.0))))
endu)
	
\end{verbatim}

Hasta aqui todos van bien, aqui su ejecuci\'on, el problema lo plantean los puntos de corte, veamos sus test y parte de la ejecuci\'on.

\begin{verbatim}
load GEO2D.maude
load ../mUnit.maude

(munit LINE is
      ***Funcion cut?-r-r.
   assertTrue(cut?-r-r(r(p(2.0 3.0) p(3.0 4.0)), r(p(5.0 3.0) p(3.0 4.0))))
   assertTrue(cut?-r-r(r(p(0.0 1.0) p(1.0 0.0)), r(p(0.0 0.0) p(1.0 1.0))))
   assertFalse(cut?-r-r(r(p(0.0 0.0) p(1.0 0.0)), r(p(1.0 1.0) p(0.0 1.0))))
   assertFalse(cut?-r-r(r(p(2.0 3.0) p(3.0 4.0)), r(p(5.0 3.0) p(6.0 4.0))))
      ***Funcion cut-point-x
   assertEqual(cut-point-x(r(p(0.0 0.0) p(2.0 2.0)), r(p(2.0 0.0) p(0.0 2.0))), 1.0)
   assertEqual(cut-point-x(r(p(2.0 3.0) p(0.0 2.0)), r(p(0.0 1.0) p(0.0 2.0))), 0.0)
      ***Funcion cut-point-y
   assertEqual(cut-point-y(r(p(0.0 0.0) p(2.0 2.0)), r(p(2.0 0.0) p(0.0 2.0))), 1.0)
   assertEqual(cut-point-y(r(p(2.0 3.0) p(0.0 3.0)), r(p(0.0 3.0) p(1.0 4.0))), 3.0)
      ***Funcion cut-point-r-r
   assertEqual(cut-point-r-r(r(p(0.0 0.0) p(1.0 2.0)), r(p(0.0 0.0) p(2.0 1.0))), p(0.0 0.0))
   assertEqual(cut-point-r-r(r(p(0.0 0.0) p(0.0 1.0)), r(p(0.0 0.0) p(1.0 0.0))), p(0.0 0.0))
   assertEqual(cut-point-r-r(r(p(0.0 0.0) p(1.0 0.0)), r(p(0.0 0.0) p(0.0 1.0))), p(0.0 0.0))
   assertEqual(cut-point-r-r(r(p(2.0 3.0) p(7.0 5.0)), r(p(9.3 2.4) p(7.0 5.0))), p(7.0 5.0))
end)
\end{verbatim}

Todos los test deber\'ian ir bien, se puede ver que se han construido con casos claros para evitar fallos humanos. Sin embargo el ultimo no funciona bien.

\begin{verbatim}

	    Full Maude 2.7 March 10th 2015


	MUnit: a unit testing framework for Maude.
		Version 1.0(November 23rd, 2016)


4 test cases were executed.

1 failures.

assertEqual(cut-point-r-r(r(p(0.0 0.0)p(1.0 2.0)),r(p(0.0 0.0)p(2.0 1.0))),p(
    0.0 0.0)) passed.
assertEqual(cut-point-r-r(r(p(0.0 0.0)p(0.0 1.0)),r(p(0.0 0.0)p(1.0 0.0))),p(
    0.0 0.0)) passed.
assertEqual(cut-point-r-r(r(p(0.0 0.0)p(1.0 0.0)),r(p(0.0 0.0)p(0.0 1.0))),p(
    0.0 0.0)) passed.
assertEqual(cut-point-r-r(r(p(2.0 3.0)p(7.0 5.0)),r(p(9.3000000000000007
    2.3999999999999999)p(7.0 5.0))),p(7.0 5.0)) failed.

\end{verbatim}

Para ver el problema calcularemos el punto por separado, pues por como hemos construidos las rectas deber\'ia devolvernos el punto p(7.0 5.0)

\begin{verbatim}

Maude> red cut-point-r-r(r(p(2.0 3.0) p(7.0 5.0)), r(p(9.3 2.4) p(7.0 5.0))) .
reduce in GEO2D : cut-point-r-r(r(p(2.0 3.0) p(7.0 5.0)), r(p(
    9.3000000000000007 2.3999999999999999) p(7.0 5.0))) .
rewrites: 88 in 0ms cpu (0ms real) (~ rewrites/second)
result Point: p(7.0000000000000009 5.0000000000000009)

\end{verbatim}

Y aqui lo tenemos, maude no se comporta bien con los decimales, y aunque sea en una posicion tan baja, la dieciseis, esos n\'umeros no son ni siete ni cinco, asi que maude nos devuelve un fallo.
Para corregir este tipo de errores incluiremos en el fmod point la primera funci\'on auxiliar, que dado dos numeros dira si son iguales en base a un epsilon que podremos elegir.

\begin{verbatim}
   op equal-epsilon : Float Float Float -> Bool .
   *** Comprueba si dos numeros reales son iguales en funcion de un epsilon.
   ceq equal-epsilon(z11, z12, a) = equal-epsilon(z12, z11, a)
   if z11 < z12 .
   ceq equal-epsilon(z11, z12, a) = true
   if (z11 >= z12) 
      /\ a > (z11 - z12) .
   ceq equal-epsilon(z11, z12, a) = false
   if (z11 >= z12) 
      /\ a <= (z11 - z12) .

\end{verbatim}   

Sus casos de test:

\begin{verbatim}
load GEO2D.maude
load ../mUnit.maude

(munit POINT is
      *** Veamos ahora la funcion equal-epsilon.
   assertTrue(equal-epsilon(5.0 ,5.00001 , 10.0 ^ (-4.0)))
   assertFalse(equal-epsilon(7.0 ,7.1 , 10.0 ^ (-2.0)))
   assertEqual(equal-epsilon(1.01010, 1.01011, 10.0 ^ (-4.0)), equal-epsilon(1.01011, 1.01010, 10.0 ^ (-4.0)))
endu)

\end{verbatim}

La ejecuci\'on de los casos de test es correcta y puede verse aqui, junto con los test anteriores y los de las funciones que se veran posteriormente. \\

Veamos ahora, si haciendo un pequeño cambio, el test que antes fallaba ahora nos da un resultado correcto.

\begin{verbatim}
load GEO2D.maude
load ../mUnit.maude

(munit LINE is
   assertEqual(cut-point-r-r(r(p(2.0 3.0) p(7.0 5.0)), r(p(9.3 2.4) p(7.0 5.0))), p(7.0 5.0))
   assertTrue(equal-epsilon(0.0, distance(cut-point-r-r(r(p(2.0 3.0) p(7.0 5.0)), r(p(9.3 2.4) p(7.0 5.0))), p(7.0 5.0)), 10.0 ^ (-5.0)))
endu)
\end{verbatim} 

Y su ejecuci\'on:

\begin{verbatim}

	    Full Maude 2.7 March 10th 2015


	MUnit: a unit testing framework for Maude.
		Version 1.0(November 23rd, 2016)


2 test cases were executed.

1 failures.

assertEqual(cut-point-r-r(r(p(2.0 3.0)p(7.0 5.0)),r(p(9.3000000000000007
    2.3999999999999999)p(7.0 5.0))),p(7.0 5.0)) failed.
assertTrue(equal-epsilon(0.0,distance(cut-point-r-r(r(p(2.0 3.0)p(7.0 5.0)),r(
    p(9.3000000000000007 2.3999999999999999)p(7.0 5.0))),p(7.0 5.0)),1.0e+1 ^
    -5.0)) passed.

\end{verbatim} 

Como podemos ver todo funciona ya bien, aunque para mi gusto la soluci\'on es muy artificial, acercandose a la teor\'ia del punto gordo m\'as que a otra cosa. Sin embargo la unica forma que habria de solucionarlo bien seria modificando la definici\'on de los numeros reales, en concreto el funcionamiento del igual con respecto a las operaciones, pero eso es algo que se sale totalmente de lo que queremos conseguir aqu\'i. \par

