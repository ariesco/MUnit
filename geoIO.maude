load GEO2D.maude
load full-maude.maude

fmod DICC-PUNTOS is
  pr GEO2D .
  pr QID .

  sorts Dic Entry Pair EmptyQID .
  subsort Entry < Dic .
  subsort EmptyQID < Qid .

  op _->_ : Qid Figura -> Entry [ctor] .
  op [_ , _] : Entry Entry -> Pair [ctor] .
  op mtD : -> Dic [ctor] .
  op emptyQID : -> EmptyQID [ctor] .
  op _._ : Dic Dic -> Dic [ctor assoc comm id: mtD] .

  var  D : Dic .
  var  Q : Qid .
  vars F F' : Figura .

  op _[_] : Dic Qid ~> Figura .
  eq (D . Q -> F)[Q] = F .

  op _[_/_] : Dic Qid Figura -> Dic .
  eq (D . Q -> F)[Q / F'] = D . Q -> F' .
  eq D[emptyQID / F] = D [owise] .
  eq D[Q / F] = D . Q -> F [owise] .


endfm

fmod GEO-SIGNATURE is
  inc FULL-MAUDE-SIGN .

  sorts @GeoCommand@ .
  subsort @GeoCommand@ < @Input@ .

  op point_as_ : @Bubble@ @Token@ -> @GeoCommand@ [ctor] .
  op circumference_in_with`radius_ : @Token@ @Token@ @Bubble@ -> @GeoCommand@ [ctor] .
  op line_from_to_ : @Token@ @Token@ @Token@ -> @GeoCommand@ [ctor] .
  op cut`point_and_of_and_ : @Token@ @Token@ @Token@ @Token@ -> @GeoCommand@ [ctor] .

endfm

fmod META-GEO-SIGN is
 inc META-FULL-MAUDE-SIGN .
 inc UNIT .

 op GEO-GRAMMAR : -> FModule [memo] .
 eq GEO-GRAMMAR = addImports((including 'GEO-SIGNATURE .), GRAMMAR) .
endfm


fmod GEO-COMMAND-PROCESSING is
 pr COMMAND-PROCESSING .
 pr DICC-PUNTOS .
 pr GEO2D .

 vars T T' T'' NP NC NR : Term .
 vars Q Q' Q'' : Qid .
 vars S S' : String .
 vars F F' : Float .
 vars P1 P2 : Punto .
 vars f1 f2 : Figura .

 op processPoint : Term Term -> Entry .
 eq processPoint('bubble[T], 'token[NP]) = downQid(NP) -> processPointAux(T) .

 op processPointAux : Term -> Punto .
 ceq processPointAux('__[T, T']) = qid2point(Q, Q')
  if Q := downQid(T) /\
     Q' := downQid(T') .

 op qid2point : Qid Qid -> Punto .
 ceq qid2point(Q, Q') = p(F F')
  if S := string(Q) /\
     S' := string(Q') /\
     F := float(S) /\
     F' := float(S') .

 op processCircumference : Term Punto Term -> Entry .
 ceq processCircumference('token[NC] , P1 , 'bubble[T]) = downQid(NC) -> c(P1 , F)
  if Q := downQid(T)
  /\ S := string(Q)
  /\ F := float(S) .

 op processLine : Term Punto Punto -> Entry .
 eq processLine('token[NR] , P1 , P2) = downQid(NR) -> r(P1 P2) .

 op processCutPoint : Term Term Figura Figura -> Pair .
 ceq processCutPoint('token[T] , 'token[T'] , f1 , f2) = [Q -> primer-elemento(pto-corte(f1 , f2)), downQid(T') -> primer-elemento(quitar-primer-elemento(pto-corte(f1 , f2)))]
 if Q := downQid(T) /\
    not (primer-elemento(pto-corte(f1 , f2)) == primer-elemento(quitar-primer-elemento(pto-corte(f1 , f2)))) /\ long-lista(pto-corte(f1 , f2)) == 2.0 .
 ceq processCutPoint('token[T] , 'token[T'] , f1 , f2) = [downQid(T) -> primer-elemento(pto-corte(f1 , f2)), downQid(T) -> primer-elemento(pto-corte(f1 , f2))]
 if primer-elemento(pto-corte(f1 , f2)) == primer-elemento(quitar-primer-elemento(pto-corte(f1 , f2))) /\ long-lista(pto-corte(f1 , f2)) == 2.0 .
 ceq processCutPoint('token[T] , 'token[T'] , f1 , f2) = [downQid(T) -> primer-elemento(pto-corte(f1 , f2)), downQid(T) -> primer-elemento(pto-corte(f1 , f2))]
 if long-lista(pto-corte(f1 , f2)) == 1.0 .
 ceq processCutPoint('token[T] , 'token[T'] , f1 , f2) = [emptyQID -> f1 , emptyQID -> f2]
 if long-lista(pto-corte(f1 , f2)) == 0.0 .

endfm

mod GEO-DATABASE-HANDLING is
 pr GEO-COMMAND-PROCESSING .
 inc DATABASE-HANDLING .
 pr DICC-PUNTOS .

 sort GEODatabaseClass .
 subsort GEODatabaseClass < DatabaseClass .

 var  MUDC : GEODatabaseClass .
 var  AtS : AttributeSet .
 var  DB : Database .
 vars T1 T2 T3 T4 : Term .
 vars F F' : Figura .
 var  O : Oid .
 var  D : Dic .
 vars Q Q' : Qid .

 op dic :_ : Dic -> Attribute [ctor] .

 crl [point] :
     < O : MUDC | input : ('point_as_[T1 , T2]), dic : D,
                  output : nil, AtS >
  => < O : MUDC | input : nilTermList, dic : (D [Q / F]),
                  output : ('Punto 'almacenado) , AtS >
  if Q -> F := processPoint(T1 , T2) .

 crl [circumference] :
     < O : MUDC | input : ('circumference_in_with`radius_[T1 , 'token[T2] , T3]), dic : D,
                  output : nil, AtS >
  => < O : MUDC | input : nilTermList, dic : (D [Q / F]),
                  output : ('Circunferencia 'almacenada) , AtS >
  if Q -> F := processCircumference(T1 , D[downQid(T2)] , T3) .

 crl [line] :
     < O : MUDC | input : ('line_from_to_[T1 , 'token[T2] , 'token[T3]]), dic : D,
                  output : nil, AtS >
  => < O : MUDC | input : nilTermList, dic : (D [Q / F]),
                  output : ('Recta 'almacenada) , AtS >
  if Q -> F := processLine(T1 , D[downQid(T2)] , D[downQid(T3)]) .

 crl [cut] :
     < O : MUDC | input : ('cut`point_and_of_and_[T1, T2, 'token[T3], 'token[T4]]), dic : D,
                  output : nil, AtS >
  => < O : MUDC | input : nilTermList, dic : ((D [Q / F]) [Q' / F']),
                  output : ('Puntos 'almacenados) , AtS >
  if [Q -> F , Q' -> F'] := processCutPoint(T1 , T2 , D[downQid(T3)] , D[downQid(T4)]) .

  op perpendicular : Dic Qid Qid -> Bool .
  eq perpendicular(D, Q, Q') = perpendicular(D[Q], D[Q']) .
endm

mod MUNIT is
 inc GEO-DATABASE-HANDLING .
 inc META-GEO-SIGN .
 inc LOOP-MODE .

 var  QI : Qid .
 vars QIL QIL' QIL'' : QidList .
 var  Atts : AttributeSet .
 var  N : Nat .
 var  DB : Database .
 vars RP RP' : ResultPair .
 var  O : Oid .
 var  X@Database : DatabaseClass .

 op o : -> Oid [ctor] .

 op GEODatabase : -> GEODatabaseClass [ctor] .

 --- State for LOOP mode:
 subsort Object < State .
 op init-geo : -> System .

 op init-state : -> AttributeSet .
 eq init-state = dic : mtD, db : initialDatabase, default : 'CONVERSION .

 op geo-banner : -> QidList .
 eq geo-banner = '\n '\t 'GEO: 'blah 'a 'unit 'testing 'framework 'for 'Maude.
           '\n '\t ' '\t '`( 'October '27th '`, '\s '2016 '`) '\n .

 rl [init] :
    init-geo
 => [nil, < o : GEODatabase | input : nilTermList, output : nil,
                              init-state >, geo-banner] .

 crl [in] :
     [QIL, < O : X@Database | input : nilTermList, Atts >, QIL']
  => [nil,
      < O : X@Database | input : getTerm(metaParse(GEO-GRAMMAR, QIL, '@Input@)), Atts >,
      QIL']
  if QIL =/= nil /\
     metaParse(GEO-GRAMMAR, QIL, '@Input@) : ResultPair .

 crl [in] :
     [QIL, < O : X@Database | output : nil, Atts >, QIL']
  => [nil,
      < O : X@Database | output : ('\r 'Warning: '\o
                printSyntaxError(metaParse(GEO-GRAMMAR, QIL, '@Input@), QIL)
                '\n
                '\r 'Error: '\o 'No 'parse 'for 'input. '\n), Atts >,
      QIL']
  if QIL =/= nil /\
     noParse(N) := metaParse(GEO-GRAMMAR, QIL, '@Input@)  .

 crl [in] :
     [QIL, < O : X@Database | output : nil, Atts >, QIL']
  => [nil,
      < O : X@Database | output :  ('\r 'Error: '\o 'Ambiguous 'input. '\n), Atts >,
      QIL']
   if QIL =/= nil /\
      ambiguity(RP, RP') := metaParse(GEO-GRAMMAR, QIL, '@Input@)  .

 rl [out] :
    [QIL, < O : X@Database | output : (QI QIL'), Atts >, QIL'']
 => [QIL, < O : X@Database | output : nil, Atts >, (QIL'' QI QIL')] .
endm

set print conceal on .
print conceal mod_is_sorts_._____endm .
print conceal fmod_is_sorts_.____endfm .
print conceal db .

loop init-geo .
