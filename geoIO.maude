load GEO2D.maude
load full-maude.maude

fmod DICC-PUNTOS is
  pr GEO2D .
  pr QID .

  sorts Dic Entry .
  subsort Entry < Dic .

  op _->_ : Qid Punto -> Entry [ctor] .
  op mtD : -> Dic [ctor] .
  op _._ : Dic Dic -> Dic [ctor assoc comm id: mtD] .

  var  D : Dic .
  var  Q : Qid .
  vars F F' : Figura .

  op _[_] : Dic Qid ~> Figura .
  eq (D . Q -> F)[Q] = F .

  op _[_/_] : Dic Qid Punto -> Dic .
  eq (D . Q -> F)[Q / F'] = D . Q -> F' .
  eq D[Q / F] = D . Q -> F [owise] .
endfm

fmod GEO-SIGNATURE is
  inc FULL-MAUDE-SIGN .

  sorts @GeoCommand@ .
  subsort @GeoCommand@ < @Input@ .

  op point_as_ : @Bubble@ @Token@ -> @GeoCommand@ [ctor] .
  op circumference_in_with`radius_ : @Token@ @Bubble@ @Bubble@ -> @GeoCommand@ [ctor] .
  op line_from_to_ : @Token@ @Bubble@ @Bubble@ -> @GeoCommand@ [ctor] . 

endfm

fmod META-GEO-SIGN is
 inc META-FULL-MAUDE-SIGN .
 inc UNIT .

 op GEO-GRAMMAR : -> FModule [memo] .
 eq GEO-GRAMMAR = addImports((including 'GEO-SIGNATURE .), GRAMMAR) .
endfm


fmod GEO-COMMAND-PROCESSING is
 pr COMMAND-PROCESSING .
 pr DICC-PUNTOS .

 vars T T' T'' NP NC NR : Term .
 vars Q Q' Q'' : Qid .
 vars S S' : String .
 vars F F' : Float .

 op processPoint : Term Term -> Entry .
 eq processPoint('bubble[T], 'token[NP]) = downQid(NP) -> processPointAux(T) .

 op processPointAux : Term -> Punto .
 ceq processPointAux('__[T, T']) = qid2point(Q, Q')
  if Q := downQid(T) /\
     Q' := downQid(T') .

 op qid2point : Qid Qid -> Punto .
 ceq qid2point(Q, Q') = p(F F')
  if S := string(Q) /\
     S' := string(Q') /\
     F := float(S) /\
     F' := float(S') .

 op processCircumference : Term Term Term -> Entry .
 eq processCircumference('token[NC] , 'bubble[T] , 'bubble[T']) = downQid(NC) -> processCircumferenceAux(T , T') .

 op processCircumferenceAux : Term Term -> Circunferencia .
 ceq processCircumferenceAux('__[T, T'] , T'') = c(qid2point(Q , Q') , F) 
  if Q := downQid(T) 
  /\ Q' := downQid(T')
  /\ Q'' := downQid(T'')
  /\ S := string(Q'')
  /\ F := float(S) .
     
 op processLine : Term Term Term -> Entry .
 eq processLine('token[NR] , 'bubble[T] , 'bubble[T']) = downQid(NR) -> r(processPointAux(T) processPointAux(T')) .

endfm

mod GEO-DATABASE-HANDLING is
 pr GEO-COMMAND-PROCESSING .
 inc DATABASE-HANDLING .
 pr DICC-PUNTOS .

 sort GEODatabaseClass .
 subsort GEODatabaseClass < DatabaseClass .

 var  MUDC : GEODatabaseClass .
 var  AtS : AttributeSet .
 var  DB : Database .
 vars T T' T'' : Term .
 var  F : Figura .
 var  O : Oid .
 var  D : Dic .
 var  Q : Qid .

 op dic :_ : Dic -> Attribute [ctor] .

 crl [point] :
     < O : MUDC | input : ('point_as_[T , T']), dic : D,
                  output : nil, AtS >
  => < O : MUDC | input : nilTermList, dic : (D [Q / F]),
                  output : 'Figura, AtS >
  if Q -> F := processPoint(T , T') .

 crl [circumference] :
     < O : MUDC | input : ('circumference_in_with`radius_[T , T' , T'']), dic : D,
                  output : nil, AtS >
  => < O : MUDC | input : nilTermList, dic : (D [Q / F]),
                  output : 'Figura, AtS >
  if Q -> F := processCircumference(T , T' , T'') .

 crl [line] :
     < O : MUDC | input : ('line_from_to_[T , T' , T'']), dic : D,
                  output : nil, AtS >
  => < O : MUDC | input : nilTermList, dic : (D [Q / F]),
                  output : 'Figura, AtS >
  if Q -> F := processLine(T , T' , T'') . 


endm

mod MUNIT is
 inc GEO-DATABASE-HANDLING .
 inc META-GEO-SIGN .
 inc LOOP-MODE .

 var  QI : Qid .
 vars QIL QIL' QIL'' : QidList .
 var  Atts : AttributeSet .
 var  N : Nat .
 var  DB : Database .
 vars RP RP' : ResultPair .
 var  O : Oid .
 var  X@Database : DatabaseClass .

 op o : -> Oid [ctor] .

 op GEODatabase : -> GEODatabaseClass [ctor] .

 --- State for LOOP mode:
 subsort Object < State .
 op init-geo : -> System .

 op init-state : -> AttributeSet .
 eq init-state = dic : mtD, db : initialDatabase, default : 'CONVERSION .

 op geo-banner : -> QidList .
 eq geo-banner = '\n '\t 'GEO: 'blah 'a 'unit 'testing 'framework 'for 'Maude.
           '\n '\t ' '\t '`( 'October '27th '`, '\s '2016 '`) '\n .

 rl [init] :
    init-geo
 => [nil, < o : GEODatabase | input : nilTermList, output : nil,
                              init-state >, geo-banner] .

 crl [in] :
     [QIL, < O : X@Database | input : nilTermList, Atts >, QIL']
  => [nil,
      < O : X@Database | input : getTerm(metaParse(GEO-GRAMMAR, QIL, '@Input@)), Atts >,
      QIL']
  if QIL =/= nil /\
     metaParse(GEO-GRAMMAR, QIL, '@Input@) : ResultPair .

 crl [in] :
     [QIL, < O : X@Database | output : nil, Atts >, QIL']
  => [nil,
      < O : X@Database | output : ('\r 'Warning: '\o
                printSyntaxError(metaParse(GEO-GRAMMAR, QIL, '@Input@), QIL)
                '\n
                '\r 'Error: '\o 'No 'parse 'for 'input. '\n), Atts >,
      QIL']
  if QIL =/= nil /\
     noParse(N) := metaParse(GEO-GRAMMAR, QIL, '@Input@)  .

 crl [in] :
     [QIL, < O : X@Database | output : nil, Atts >, QIL']
  => [nil,
      < O : X@Database | output :  ('\r 'Error: '\o 'Ambiguous 'input. '\n), Atts >,
      QIL']
   if QIL =/= nil /\
      ambiguity(RP, RP') := metaParse(GEO-GRAMMAR, QIL, '@Input@)  .

 rl [out] :
    [QIL, < O : X@Database | output : (QI QIL'), Atts >, QIL'']
 => [QIL, < O : X@Database | output : nil, Atts >, (QIL'' QI QIL')] .
endm

set print conceal on .
print conceal mod_is_sorts_._____endm .
print conceal fmod_is_sorts_.____endfm .
print conceal db .

loop init-geo .
