load aux_modules.maude
load full-maude.maude

fmod MUNIT-SIGNATURE is
  inc FULL-MAUDE-SIGN .

  sorts @MUnitModule@ @MUnitPredicate@ @MUnitPredList@ .
  subsort @MUnitPredicate@ < @MUnitPredList@ .

  subsort @MUnitModule@ < @Input@ .

  op __ : @MUnitPredList@ @MUnitPredList@ -> @MUnitPredList@ [ctor assoc] .

  *********************************************************************************
  *** Indicates that the term introduced in the test is evaluated to true       ***
  *** Usage: assertTrue(f(t_1, ..., t_n))                                       ***
  *********************************************************************************
  op assertTrue : @Bubble@ -> @MUnitPredicate@ [ctor] .

  *** For testing purposes, functionality will be moved to assertTrue later
  op assertTrueLoop : @Bubble@ -> @MUnitPredicate@ [ctor] .

  *********************************************************************************
  *** Indicates that the term introduced in the test is evaluated to true       ***
  *** and print the given message                                               ***
  *** Usage: assertTrueMsg(f(t_1, ..., t_n), "Error in f")                      ***
  *********************************************************************************
  op assertTrueMsg : @Bubble@ @Token@ -> @MUnitPredicate@ [ctor] .

  op assertEqual : @Bubble@ @Bubble@ -> @MUnitPredicate@ [ctor comm] .
  op assertReachable : @Bubble@ @Bubble@ -> @MUnitPredicate@ [ctor] .
  op assertReachableBnd : @Bubble@ @Bubble@ @Token@ -> @MUnitPredicate@ [ctor] .

  *********************************************************************************
  *** Indicates that the term introduced in the test must have the given sort.  ***
  *** It passes if the sort of the term is lesser or equal than the given sort. ***
  *** Usage: assertSort(f(t_1, ..., t_n), Sort)                                 ***
  *********************************************************************************
  op assertSort : @Bubble@ @Token@ -> @MUnitPredicate@ [ctor] .

  *********************************************************************************
  *** Restarts the loop.                                                        ***
  *** Usage: loop(your-init)                                                    ***
  *********************************************************************************
  op loop : @Token@ -> @MUnitPredicate@ [ctor] .

  *********************************************************************************
  *** Applies a new command in the loop                                         ***
  *** Usage: command(COMM), with COMM a command in the current system           ***
  *********************************************************************************
  op command : @Bubble@ -> @MUnitPredicate@ [ctor] .

  op munit_is_endu : @ModExp@ @MUnitPredList@ -> @MUnitModule@ [ctor] .
endfm


fmod META-MUNIT-SIGN is
 inc META-FULL-MAUDE-SIGN .
 inc UNIT .

 op MUNIT-GRAMMAR : -> FModule [memo] .
 eq MUNIT-GRAMMAR = addImports((including 'MUNIT-SIGNATURE .), GRAMMAR) .
endfm

fmod MUNIT-COMMAND-PROCESSING is
 pr COMMAND-PROCESSING .
 pr PRINT .

 vars T T' T'' T1 T2 T3 TSB TSB' SYS SYS' SYS'' : Term .
 var  ME : ModuleExpression .
 vars QIL QIL' : QidList .
 vars DB DB' : Database .
 vars N N' N1 N1' : Nat .
 var  VDS : OpDeclSet .
 var  SS : SortSet .
 var  T? : [Term] .
 var  M : Module .
 var  S : Sort .
 var  B : Bool .
 var  Q : Qid .

 op printOpts : -> PrintOptionSet .
 eq printOpts = mixfix number rat format .

 op procMUnit : Term Term Database -> UnitResult .
 ceq procMUnit(T, T', DB) = procMUnitAux(ME, T', DB')
  if < DB' ; ME > := evalModExp(parseModExp(T), DB) .
 eq procMUnit(T, T', DB) = < 0, 0, '\n '\r '\! 'Error: '\o
                                  'Wrong 'module 'expression. '\n > [owise] .

 op procMUnitAux : ModuleExpression Term Database -> UnitResult .
 ceq procMUnitAux(ME, T, DB) = normalize(procProps(M, T, VDS, B, DB, 'noSys.System))
  if compiledModule(ME, DB) /\
     M := getFlatModule(ME, DB) /\
     VDS := getVars(ME, DB) /\
     B := included('META-MODULE, getImports(getTopModule(ME, DB)), DB) .
 ceq procMUnitAux(ME, T, DB) = normalize(procProps(M, T, VDS, B, DB', 'noSys.System))
  if not compiledModule(ME, DB) /\
     DB' := database(evalModExp(ME, DB)) /\
     M := getFlatModule(ME, DB') /\
     VDS := getVars(ME, DB') /\
     B := included('META-MODULE, getImports(getTopModule(ME, DB')), DB') .
 eq procMUnitAux(ME, T, DB) = < 0, 0, '\n '\r '\! 'Error: '\o 'The
                                  'module 'cannot 'be 'compiled. '\n > [owise] .

 op procProps : Module Term OpDeclSet Bool Database Term -> UnitResult .
 ceq procProps(M, '__[T, T'], VDS, B, DB, SYS) = < N + N', N1 + N1', QIL QIL' >
  if [N, N1, QIL, SYS'] := procProps(M, T, VDS, B, DB, SYS) /\
     [N', N1', QIL', SYS''] := procProps(M, T', VDS, B, DB, SYS') .

 ceq procProps(M, 'assertTrue[T], VDS, B, DB, SYS) = [1, 0, nil, SYS]
  if T1 := reduce(M, solveBubbles(T, M, B, VDS, DB)) /\
     T1 == 'true.Bool .
 ceq procProps(M, 'assertTrue[T], VDS, B, DB, SYS) = [0, 1, nil, SYS]
  if T1 := reduce(M, solveBubbles(T, M, B, VDS, DB)) /\
     T1 == 'false.Bool .
 ceq procProps(M, 'assertTrue[T], VDS, B, DB, SYS) = [0, 1, ('\n '\r 'Error: '\o getMsg(T?)), SYS]
  if T? := reduce(M, solveBubbles(T, M, B, VDS, DB)) /\
     not (T? :: Term) .

 ceq procProps(M, 'assertTrueMsg[T, T'], VDS, B, DB, SYS) = [1, 0, nil, SYS]
  if T1 := reduce(M, solveBubbles(T, M, B, VDS, DB)) /\
     T1 == 'true.Bool .
 ceq procProps(M, 'assertTrueMsg[T, 'token[T']], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if TSB := solveBubbles(T, M, B, VDS, DB) /\
     T1 := reduce(M, TSB) /\
     T1 == 'false.Bool /\
     QIL := '\n 'Error 'for 'assertTrue '`( metaPrettyPrint(M, TSB, printOpts) '`)
            ' '---> ' downQid(T') '\n .
 ceq procProps(M, 'assertTrueMsg[T, T'], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if T? := reduce(M, solveBubbles(T, M, B, VDS, DB)) /\
     not (T? :: Term) /\
     QIL := ('\n '\r 'Error: '\o getMsg(T?)) .

 ceq procProps(M, 'assertEqual[T, T'], VDS, B, DB, SYS) = [1, 0, nil, SYS]
  if T1 := reduce(M, solveBubbles(T, M, B, VDS, DB)) /\
     T1 := reduce(M, solveBubbles(T', M, B, VDS, DB)) .
 ceq procProps(M, 'assertEqual[T, T'], VDS, B, DB, SYS) = [0, 1, nil, SYS]
  if T1 := reduce(M, solveBubbles(T, M, B, VDS, DB)) /\
     T2 := reduce(M, solveBubbles(T', M, B, VDS, DB)) /\
     T1 =/= T2 .
 ceq procProps(M, 'assertEqual[T, T'], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if T? := solveBubbles(T, M, B, VDS, DB) /\
     not (T? :: Term) /\
     QIL := ('\n '\r 'Error: '\o getMsg(T?)) .
 ceq procProps(M, 'assertEqual[T, T'], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if T? := solveBubbles(T', M, B, VDS, DB) /\
     not (T? :: Term) /\
     QIL := ('\n '\r 'Error: '\o getMsg(T?)) .

 *** TODO: Error eqs
 ceq procProps(M, 'loop['token[T]], VDS, B, DB, SYS) = [0, 0, nil, T'']
  if Q := downQid(T) /\
     T' := qid(string(Q) + ".System") /\
     T'' := rewrite(M, T') [print "Exito"] .

 *** TODO: Error eqs
 ceq procProps(M, 'command['bubble[T]], VDS, B, DB, SYS) = [0, 0, nil, SYS]
  if QIL := downQidList(T) /\
     T' := upTerm(QIL) /\
     SYS' := sysInput(SYS, T') /\
     SYS'' := rewrite(M, SYS') [print SYS''] .

 ceq procProps(M, 'assertSort[T, 'token[T']], VDS, B, DB, SYS) = [1, 0, nil, SYS]
  if { T1, S } := metaReduce(M, solveBubbles(T, M, B, VDS, DB)) /\
     Q := downQid(T') /\
     Q ; SS := getSorts(M) /\
     sameKind(M, Q, S) /\
     sortLeq(M, S, Q) .
 ceq procProps(M, 'assertSort[T, 'token[T']], VDS, B, DB, SYS) = [0, 1, nil, SYS]
  if { T1, S } := metaReduce(M, solveBubbles(T, M, B, VDS, DB)) /\
     Q := downQid(T') /\
     Q ; SS := getSorts(M) /\
     sameKind(M, Q, S) /\
     not sortLeq(M, S, Q) .
 ceq procProps(M, 'assertSort[T, 'token[T']], VDS, B, DB, SYS) = [0, 1, nil, SYS]
  if { T1, S } := metaReduce(M, solveBubbles(T, M, B, VDS, DB)) /\
     Q := downQid(T') /\
     Q ; SS := getSorts(M) /\
     not sameKind(M, Q, S) .
 ceq procProps(M, 'assertSort[T, 'token[T']], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if T? := solveBubbles(T, M, B, VDS, DB) /\
     not (T? :: Term) /\
     QIL := ('\n '\r 'Error: '\o getMsg(T?)) .

 ceq procProps(M, 'assertReachable[T, T'], VDS, B, DB, SYS) = [1, 0, nil, SYS]
  if T1 := reduce(M, solveBubbles(T, M, B, VDS, DB)) /\
     T2 := reduce(M, solveBubbles(T', M, B, VDS, DB)) /\
     metaSearch(M, T1, T2, nil, '*, unbounded, 0) =/= failure .
 ceq procProps(M, 'assertReachable[T, T'], VDS, B, DB, SYS) = [0, 1, nil, SYS]
  if T1 := reduce(M, solveBubbles(T, M, B, VDS, DB)) /\
     T2 := reduce(M, solveBubbles(T', M, B, VDS, DB)) /\
     metaSearch(M, T1, T2, nil, '*, unbounded, 0) == failure .
 ceq procProps(M, 'assertReachable[T, T'], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if T? := solveBubbles(T, M, B, VDS, DB) /\
     not (T? :: Term) /\
     QIL := ('\n '\r 'Error: '\o getMsg(T?)) .
 ceq procProps(M, 'assertReachable[T, T'], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if T? := solveBubbles(T', M, B, VDS, DB) /\
     not (T? :: Term) /\
     QIL := ('\n '\r 'Error: '\o getMsg(T?)) .

 ceq procProps(M, 'assertReachableBnd[T, T', 'token[T'']], VDS, B, DB, SYS) = [1, 0, nil, SYS]
  if T1 := reduce(M, solveBubbles(T, M, B, VDS, DB)) /\
     T2 := reduce(M, solveBubbles(T', M, B, VDS, DB)) /\
     N := rat(string(downQid(T'')), 10) /\
     metaSearch(M, T1, T2, nil, '*, N, 0) =/= failure .
 ceq procProps(M, 'assertReachableBnd[T, T', T''], VDS, B, DB, SYS) = [0, 1, nil, SYS]
  if T1 := reduce(M, solveBubbles(T, M, B, VDS, DB)) /\
     T2 := reduce(M, solveBubbles(T', M, B, VDS, DB)) /\
     N := rat(string(downQid(T'')), 10) /\
     metaSearch(M, T1, T2, nil, '*, N, 0) == failure .
 ceq procProps(M, 'assertReachableBnd[T, T', T''], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if T? := solveBubbles(T, M, B, VDS, DB) /\
     not (T? :: Term) /\
     QIL := ('\n '\r 'Error: '\o getMsg(T?)) .
 ceq procProps(M, 'assertReachableBnd[T, T', T''], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if not (rat(string(downQid(T'')), 10) :: Nat) /\
     QIL := ('\n '\r 'Error: '\o 'Not 'a 'number) .

 eq procProps(M, Q[T, T'], VDS, B, DB, SYS) = [0, 1, nil, SYS] [owise] .
 eq procProps(M, Q[T], VDS, B, DB, SYS) = [0, 1, nil, SYS] [owise] .

 op reduce : Module Term -> Term .
 eq reduce(M, T) = getTerm(metaReduce(M, T)) .

 op rewrite : Module Term -> Term .
 eq rewrite(M, T) = getTerm(metaRewrite(M, T, unbounded)) .

 *** This function introduces new input into the loop
 op sysInput : Term Term -> Term .
 eq sysInput(Q[T1, T2, T3], T) = Q[T, T2, T3] .

 op rename@InInput : Module Term -> Term .

endfm

mod MUNIT is
 pr MUNIT-COMMAND-PROCESSING .
 inc DATABASE-HANDLING .
 inc META-MUNIT-SIGN .
 pr PRINT .

 var  MUDC : MUDatabaseClass .
 var  AtS : AttributeSet .
 var  UR : UnitResult .
 var  DB : Database .
 vars T T' : Term .
 var  O : Oid .

 sort MUDatabaseClass .
 subsort MUDatabaseClass < DatabaseClass .

 op MUDatabase : -> MUDatabaseClass [ctor] .

 crl [munit] :
     < O : MUDC | db : DB, input : ('munit_is_endu[T, T']), output : nil, AtS >
  => < O : MUDC | db : DB, input : nilTermList, output : printUR(UR), AtS >
  if UR := procMUnit(T, T', DB) .

 *** Comparar atributos con upTerm

endm

mod MUNIT-INIT is
 inc LOOP-MODE .
 pr MUNIT .

 var  QI : Qid .
 vars QIL QIL' QIL'' : QidList .
 var  Atts : AttributeSet .
 var  N : Nat .
 var  DB : Database .
 vars RP RP' : ResultPair .
 var  O : Oid .
 var  X@Database : DatabaseClass .

 op o : -> Oid [ctor] .

 --- State for LOOP mode:
 subsort Object < State .
 op init-munit : -> System .

 op init-state : -> AttributeSet .
 eq init-state = db : initialDatabase, default : 'CONVERSION .

 rl [init] :
    init-munit
 => [nil, < o : MUDatabase | input : nilTermList, output : nil, init-state >, mu-banner] .

 crl [in] :
     [QIL, < O : X@Database | input : nilTermList, Atts >, QIL']
  => [nil,
      < O : X@Database | input : getTerm(metaParse(MUNIT-GRAMMAR, QIL, '@Input@)), Atts >,
      QIL']
  if QIL =/= nil /\
     metaParse(MUNIT-GRAMMAR, QIL, '@Input@) : ResultPair .

 crl [in] :
     [QIL, < O : X@Database | output : nil, Atts >, QIL']
  => [nil,
      < O : X@Database | output : ('\r 'Warning: '\o
                printSyntaxError(metaParse(MUNIT-GRAMMAR, QIL, '@Input@), QIL)
                '\n
                '\r 'Error: '\o 'No 'parse 'for 'input. '\n), Atts >,
      QIL']
  if QIL =/= nil /\
     noParse(N) := metaParse(MUNIT-GRAMMAR, QIL, '@Input@)  .

 crl [in] :
     [QIL, < O : X@Database | output : nil, Atts >, QIL']
  => [nil,
      < O : X@Database | output :  ('\r 'Error: '\o 'Ambiguous 'input. '\n), Atts >,
      QIL']
   if QIL =/= nil /\
      ambiguity(RP, RP') := metaParse(MUNIT-GRAMMAR, QIL, '@Input@)  .

 rl [out] :
    [QIL, < O : X@Database | output : (QI QIL'), Atts >, QIL'']
 => [QIL, < O : X@Database | output : nil, Atts >, (QIL'' QI QIL')] .
endm

set print conceal on .
print conceal mod_is_sorts_._____endm .
print conceal fmod_is_sorts_.____endfm .
print conceal db .

*** for debugging purposes
set print attribute on .

loop init-munit .

