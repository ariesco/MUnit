fmod UNIT-RESULT is
 pr QID-LIST .

 sort UnitResult .

 *** Correct test, failed tests, Tests info
 op <_,_,_> : Nat Nat QidList -> UnitResult [ctor] .
endfm

fmod AUX is
 pr META-LEVEL .
 pr CONVERSION .

 vars SSDS SSDS' : SubsortDeclSet .
 vars ODS ODS' : OpDeclSet .
 vars AtS AtS' : AttrSet .
 vars TL TL' : TermList .
 vars SS SS' : SortSet .
 var  COND : Condition .
 var  ES : EquationSet .
 vars T T' T'' : Term .
 var  MAS : MembAxSet .
 var  IL : ImportList .
 var  TyL : TypeList .
 var  Ct : Constant .
 var  QIL : QidList .
 var  RS : RuleSet .
 vars QI F : Qid .
 var  M : Module .
 var  Ty : Type .
 var  S : Sort .
 var  N : Nat .

 op printOpts : -> PrintOptionSet .
 eq printOpts = mixfix number rat format .

 op downQid : Term -> [Qid] .
 eq downQid(Ct)
    = qid(substr(string(getName(Ct)), 1, length(string(getName(Ct))))) .

 op downQidList : Term -> [QidList] .
 eq downQidList('nil.TypeList) = nil .
 eq downQidList('__[TL]) = downQidList(TL) .
 ceq downQidList((TL, TL')) = (downQidList(TL) downQidList(TL'))
  if TL =/= empty /\ TL' =/= empty .
 eq downQidList(QI) = downQid(QI) [owise] .

 op reduce : Module Term -> Term [memo] .
 eq reduce(M, T) = getTerm(metaReduce(M, T)) .

 op rewrite : Module Term -> Term .
 eq rewrite(M, T) = getTerm(metaRewrite(M, T, unbounded)) .

 op printCond : Module Condition ~> QidList .
 eq printCond(M, nil) = 'nil .
 eq printCond(M, COND) = $printCond(M, COND) [owise] .

 op $printCond : Module Condition ~> QidList .
 eq $printCond(M, nil) = nil .
 eq $printCond(M, T = T' /\ COND) = metaPrettyPrint(M, T, printOpts) '=
                                    metaPrettyPrint(M, T', printOpts)
                                    if COND == nil
                                    then nil
                                    else '/\ $printCond(M, COND)
                                    fi .
 eq $printCond(M, T := T' /\ COND) = metaPrettyPrint(M, T, printOpts) ':=
                                     metaPrettyPrint(M, T', printOpts)
                                    if COND == nil
                                    then nil
                                    else '/\ $printCond(M, COND)
                                    fi .
 eq $printCond(M, T => T' /\ COND) = metaPrettyPrint(M, T, printOpts) '=>
                                     metaPrettyPrint(M, T', printOpts)
                                    if COND == nil
                                    then nil
                                    else '/\ $printCond(M, COND)
                                    fi .
 eq $printCond(M, T : Ty /\ COND) = metaPrettyPrint(M, T, printOpts) ': Ty
                                    if COND == nil
                                    then nil
                                    else '/\ $printCond(M, COND)
                                    fi .

 op printBound : Bound -> Qid .
 eq printBound(unbounded) = 'unbounded .
 eq printBound(N) = qid(string(N, 10)) .

 op solveBubbles : Module Term ~> Term [memo] .
 ceq solveBubbles(M, 'bubble[T]) = T'
  if QIL := downQidList(T) /\
     {T', Ty} := metaParse(M, QIL, anyType) .

 op solveBubblesCond : Module Term ~> Condition [memo] .
 ceq solveBubblesCond(M, 'bubble[T]) = COND
  if QIL := downQidList(T) /\
     {T', Ty} := metaParse(M, QIL, '@Condition@) /\
     COND := parseCond(T') [print COND] .

 op parseCond : Term -> Condition .
 eq parseCond('_/\_[T, T']) = parseCond(T) /\ parseCond(T') .
 eq parseCond('_=_[T, T']) = T = T' .
 eq parseCond('_:_[T, T']) = T : getName(T') .
 eq parseCond('_:=_[T, T']) = T := T' .
 eq parseCond('_=>_[T, T']) = T => T' .
 eq parseCond(T) = T = 'true.Bool [owise] .

 op addInfoConds : Module -> [Module] .
 op addInfoConds : Module SortSet -> Module .

 eq addInfoConds(M) = addInfoConds(M, getSorts(M)) .

 eq addInfoConds(M, '@Token@ ; SS) = addInfoConds(M, SS) .
 eq addInfoConds(M, '@Bubble@ ; SS) = addInfoConds(M, SS) .
 eq addInfoConds(M, S ; SS)
   = addInfoConds(
       addOps(op qid(string(S)) : nil -> '@Sort@ [ctor] .
              op '_:_ : S '@Sort@ -> '@Condition@ [ctor prec(71)] ., M),
       SS)
   [owise] .
 eq addInfoConds(M, none)
   = addOps(op '_/\_ : '@Condition@ '@Condition@ -> '@Condition@
                              [ctor assoc prec(73)] .
            op '_=_  : 'Universal 'Universal -> '@Condition@
                              [ctor poly(1 2) prec(71)] .
            op '_:=_ : 'Universal 'Universal -> '@Condition@
                              [ctor poly(1 2) prec(71)] .
            op '_=>_ : 'Universal 'Universal -> '@Condition@
                              [ctor poly(1 2) prec(71)] .,
       addSorts('@Condition@ ; '@Sort@,
         if 'Bool in getSorts(M)
         then addSubsorts(subsort 'Bool < '@Condition@ ., M)
         else M
         fi)) .

 op addOps : OpDeclSet Module -> Module [memo] .
 eq addOps(ODS', fmod QI is IL sorts SS . SSDS ODS MAS ES endfm)
   = fmod QI is IL sorts SS . SSDS
     override(ODS, ODS')
     MAS ES endfm .
 eq addOps(ODS', mod QI is IL sorts SS . SSDS ODS MAS ES RS endm)
   = mod QI is IL sorts SS . SSDS
     override(ODS, ODS')
     MAS ES RS endm .

 op addSorts : SortSet Module -> Module [memo] .
 eq addSorts(SS', fmod QI is IL sorts SS . SSDS ODS MAS ES endfm)
   = fmod QI is IL sorts (SS' ; SS) . SSDS ODS MAS ES endfm .
 eq addSorts(SS', mod QI is IL sorts SS . SSDS ODS MAS ES RS endm)
   = mod QI is IL sorts (SS' ; SS) . SSDS ODS MAS ES RS endm .

 op addSubsorts : SubsortDeclSet Module -> Module [memo] .
 eq addSubsorts(SSDS', fmod QI is IL sorts SS . SSDS ODS MAS ES endfm)
   = fmod QI is IL sorts SS . (SSDS SSDS') ODS MAS ES endfm .
 eq addSubsorts(SSDS', mod QI is IL sorts SS . SSDS ODS MAS ES RS endm)
   = mod QI is IL sorts SS . (SSDS SSDS') ODS MAS ES RS endm .

 op override : OpDeclSet OpDeclSet -> OpDeclSet .
 eq override(
      (op F : TyL -> Ty [AtS] .)  ODS,
      (op F : TyL -> Ty [AtS'] .) ODS')
   = override(ODS,(op F : TyL -> Ty [AtS'] .) ODS') .
  eq override(ODS, ODS') = ODS ODS' [owise] .
endfm

fmod MUNIT-COMMAND-PROCESSING is
 pr UNIT-RESULT .
 pr AUX .

 vars T T' T'' T''' T1 T2 T3 T4 TSB TSB' TSB'' TI TI' TI1 TIS TIS' TIS1 TIS1' MSG : Term .
 vars QIL QIL' QILI QILI' : QidList .
 vars TL TL' TL'' : TermList .
 vars SB SB' : Substitution .
 vars St St' St'' : String .
 vars VDS ODS : OpDeclSet .
 var  COND? : [Condition] .
 vars N N' N1 N1' : Nat .
 var  COND : Condition .
 var  UR : UnitResult .
 vars Ty Ty' : Type .
 var  AtS : AttrSet .
 var  V : Variable .
 var  SS : SortSet .
 var  C : Constant .
 var  BND : Bound .
 var  T? : [Term] .
 var  M : Module .
 vars Q Q' : Qid .
 var  S : Sort .
 var  B : Bool .

 op procMUnit : Term -> UnitResult .
 ceq procMUnit('munit_is_endu['token[T], T']) = procMUnit(Q, T')
  if Q := downTerm(T, 'error) .

 op procMUnit : Qid Term -> UnitResult .
 ceq procMUnit(Q, T) = procProps(M, T)
  if M := upModule(Q, true) .
 eq procMUnit(Q, T) = < 0, 0, '\n '\r '\! 'Error: '\o 'The
                              'module 'is 'not 'loaded. '\n > [owise] .

 op procProps : Module Term -> UnitResult .
 ceq procProps(M, '__[T, T']) = < N + N', N1 + N1', QIL QIL' >
  if < N, N1, QIL > := procProps(M, T) /\
     < N', N1', QIL' > := procProps(M, T') .

 *********************************************************************************
 ********************                assertTrue               ********************
 *********************************************************************************
 ceq procProps(M, 'assertTrue[T]) = < 1, 0, QIL' >
  if T' := solveBubbles(M, T) /\
     reduce(M, T') == 'true.Bool /\
     QIL' := '\! '\n 'assertTrue '`( metaPrettyPrint(M, T', printOpts) '`) '
             '\g 'passed. '\o '\n .
 ceq procProps(M, 'assertTrue[T]) = < 0, 1, QIL' >
  if T' := solveBubbles(M, T) /\
     T2 := reduce(M, T') /\
     T2 =/= 'true.Bool /\
     QIL' := '\! '\n 'assertTrue '`( metaPrettyPrint(M, T', printOpts) '`) '
             '\r 'failed. '\o '\n
             '\! 'Term 'reduced 'to metaPrettyPrint(M, T2, printOpts) '\o '\n .
 ceq procProps(M, 'assertTrue[T]) = < 0, 1, QIL' >
  if 'bubble[T1] := T /\
     QIL := downQidList(T1) /\
     not (solveBubbles(M, T) :: Term) /\
     QIL' := '\! '\n '\r 'No 'parse 'for '\o
             '\n QIL '\n .

 **********************************************************************************
 ********************                assertFalse               ********************
 **********************************************************************************
 ceq procProps(M, 'assertFalse[T]) = < 1, 0, QIL' >
  if T' := solveBubbles(M, T) /\
     reduce(M, T') == 'false.Bool /\
     QIL' := '\! '\n 'assertFalse '`( metaPrettyPrint(M, T', printOpts) '`) '
             '\g 'passed. '\o '\n .
 ceq procProps(M, 'assertFalse[T]) = < 0, 1, QIL' >
  if T' := solveBubbles(M, T) /\
     T2 := reduce(M, T') /\
     T2 =/= 'false.Bool /\
     QIL' := '\! '\n 'assertFalse '`( metaPrettyPrint(M, T', printOpts) '`) '
             '\r 'failed. '\o '\n
             '\! 'Term 'reduced 'to metaPrettyPrint(M, T2, printOpts) '\o '\n .
 ceq procProps(M, 'assertFalse[T]) = < 0, 1, QIL' >
  if 'bubble[T1] := T /\
     QIL := downQidList(T1) /\
     not (solveBubbles(M, T) :: Term) /\
     QIL' := '\! '\n '\r 'No 'parse 'for '\o
             '\n QIL '\n .

 *********************************************************************************
 *******************                assertTrueMsg             ********************
 *********************************************************************************
 ceq procProps(M, 'assertTrueMsg[T, 'token[MSG]]) = < 1, 0, QIL' >
  if T' := solveBubbles(M, T) /\
     reduce(M, T') == 'true.Bool /\
     QIL' := '\! '\n 'assertTrue '`( metaPrettyPrint(M, T', printOpts) '`) '
             '\g 'passed. '\o '\n
            ' '---> ' downQid(MSG) '\n .
 ceq procProps(M, 'assertTrueMsg[T, 'token[MSG]]) = < 0, 1, QIL' >
  if T' := solveBubbles(M, T) /\
     T2 := reduce(M, T') /\
     T2 =/= 'true.Bool /\
     QIL' := '\! '\n 'assertTrue '`( metaPrettyPrint(M, T', printOpts) '`) '
             '\r 'failed. '\o '\n
             '\! 'Term 'reduced 'to metaPrettyPrint(M, T2, printOpts) '\o '\n
             ' '---> ' downQid(MSG) '\n .
 ceq procProps(M, 'assertTrueMsg[T, 'token[MSG]]) = < 0, 1, QIL' >
  if 'bubble[T1] := T /\
     QIL := downQidList(T1) /\
     not (solveBubbles(M, T) :: Term) /\
     QIL' := '\! '\n '\r 'No 'parse 'for '\o
             '\n QIL '\n
             ' '---> ' downQid(MSG) '\n .

 **********************************************************************************
 ********************                assertEqual               ********************
 **********************************************************************************
 ceq procProps(M, 'assertEqual[T, T']) = < 1, 0, QIL >
  if TSB := solveBubbles(M, T) /\
     TSB' := solveBubbles(M, T') /\
     reduce(M, TSB) == reduce(M, TSB') /\
     QIL := '\! '\n 'assertEqual '`( metaPrettyPrint(M, TSB, printOpts) '`,
            metaPrettyPrint(M, TSB', printOpts) '`) ' '\g 'passed. '\o '\n .
 ceq procProps(M, 'assertEqual[T, T']) = < 0, 1, QIL >
  if TSB := solveBubbles(M, T) /\
     TSB' := solveBubbles(M, T') /\
     T1 := reduce(M, TSB) /\
     T2 := reduce(M, TSB') /\
     T1 =/= T2 /\
     QIL := '\! '\n 'assertEqual '`( metaPrettyPrint(M, TSB, printOpts) '`,
            metaPrettyPrint(M, TSB', printOpts) '`) ' '\r 'failed. '\o '\n
            '\! 'First 'term 'reduced 'to metaPrettyPrint(M, T1, printOpts) '\o '\n
            '\! 'Second 'term 'reduced 'to metaPrettyPrint(M, T2, printOpts) '\o '\n .
 ceq procProps(M, 'assertEqual[T, T']) = < 0, 1, QIL' >
  if 'bubble[T1] := T /\
     QIL := downQidList(T1) /\
     not (solveBubbles(M, T) :: Term) /\
     QIL' := '\! '\n '\r 'No 'parse 'for '\o
             '\n QIL '\n .
 ceq procProps(M, 'assertEqual[T, T']) = < 0, 1, QIL' >
  if 'bubble[T1] := T' /\
     QIL := downQidList(T1) /\
     not (solveBubbles(M, T) :: Term) /\
     QIL' := '\! '\n '\r 'No 'parse 'for '\o
             '\n QIL '\n .

 **************************************************************************************
 ********************                assertDifferent               ********************
 **************************************************************************************
 ceq procProps(M, 'assertDifferent[T, T']) = < 0, 1, QIL >
  if TSB := solveBubbles(M, T) /\
     TSB' := solveBubbles(M, T') /\
     T1 := reduce(M, TSB) /\
     T1 == reduce(M, TSB') /\
     QIL := '\! '\n 'assertDifferent '`( metaPrettyPrint(M, TSB, printOpts) '`,
            metaPrettyPrint(M, TSB', printOpts) '`) ' '\r 'failed. '\o '\n
            'Terms 'reduced 'to metaPrettyPrint(M, T1, printOpts) '\n .
 ceq procProps(M, 'assertDifferent[T, T']) = < 1, 0, QIL >
  if TSB := solveBubbles(M, T) /\
     TSB' := solveBubbles(M, T') /\
     reduce(M, TSB) =/= reduce(M, TSB') /\
     QIL := '\! '\n 'assertDifferent '`( metaPrettyPrint(M, TSB, printOpts) '`,
            metaPrettyPrint(M, TSB', printOpts) '`) ' '\g 'passed. '\o '\n .
 ceq procProps(M, 'assertDifferent[T, T']) = < 0, 1, QIL >
  if 'bubble[T1] := T /\
     QIL := downQidList(T1) /\
     not (solveBubbles(M, T) :: Term) /\
     QIL' := '\! '\n '\r 'No 'parse 'for '\o
             '\n QIL '\n .
 ceq procProps(M, 'assertDifferent[T, T']) = < 0, 1, QIL >
  if 'bubble[T1] := T' /\
     QIL := downQidList(T1) /\
     not (solveBubbles(M, T) :: Term) /\
     QIL' := '\! '\n '\r 'No 'parse 'for '\o
             '\n QIL '\n .

 **********************************************************************************
 ********************                hasSolution               ********************
 **********************************************************************************
 ceq procProps(M, 'hasSolution[T, T', T'', T3, T4]) = UR
  if TSB := solveBubbles(M, T) /\
     TSB' := solveBubbles(M, T') /\
     'token[TI] := T'' /\
     Q := downQid(TI) /\
     (Q == '! or Q == '* or Q == '+) /\
     'token[TI'] := T3 /\
     Q' := downQid(TI') /\
     BND := if Q' == 'unbounded
            then unbounded
            else rat(string(Q'), 10)
            fi /\
     ((T4 == 'bubble[''nil.Qid]) or (solveBubblesCond(addInfoConds(M), T4) :: Condition)) /\
     UR := if T4 == 'bubble[''nil.Qid]
           then procSolution(M, TSB, TSB', Q, BND, nil)
           else procSolution(M, TSB, TSB', Q, BND, solveBubblesCond(addInfoConds(M), T4))
           fi .
 ceq procProps(M, 'hasSolution[T, T', T'', T3, T4]) = < 0, 1, QIL' >
  if 'bubble[T1] := T /\
     QIL := downQidList(T1) /\
     not (solveBubbles(M, T) :: Term) /\
     QIL' := '\! '\n '\r 'No 'parse 'for '\o
             '\n QIL '\n .
 ceq procProps(M, 'hasSolution[T, T', T'', T3, T4]) = < 0, 1, QIL' >
  if 'bubble[T1] := T' /\
     QIL := downQidList(T1) /\
     not (solveBubbles(M, T) :: Term) /\
     QIL' := '\! '\n '\r 'No 'parse 'for '\o
             '\n QIL '\n .
 ceq procProps(M, 'hasSolution[T, T', T'', T3, T4]) = < 0, 1, QIL >
  if 'token[TI] := T'' /\
     Q := downQid(TI) /\
     not (Q == '! or Q == '* or Q == '+) /\
     QIL := '\! '\n '\r 'Invalid 'search 'arrow. '\o '\n .
 ceq procProps(M, 'hasSolution[T, T', T'', T3, T4]) = < 0, 1, QIL >
  if 'token[TI'] := T3 /\
     Q' := downQid(TI') /\
     not ((Q' == 'unbounded) or (rat(string(Q'), 10) :: Nat)) /\
     QIL := '\! '\n '\r 'Invalid 'bound. '\o '\n .
 ceq procProps(M, 'hasSolution[T, T', T'', T3, T4]) = < 0, 1, QIL >
  if not ((T4 == 'bubble[''nil.Qid]) or (solveBubblesCond(addInfoConds(M), T4) :: Condition)) /\
     QIL := '\! '\n '\r 'Invalid 'condition. '\o '\n .

 op procSolution : Module Term Term Qid Bound Condition -> UnitResult .
 ceq procSolution(M, T, T', Q, BND, COND) = < 1, 0, QIL >
  if metaSearch(M, T, T', COND, Q, BND, 0) =/= failure /\
     QIL := '\! '\n 'hasSolution '`( metaPrettyPrint(M, T, printOpts) '`, '
            metaPrettyPrint(M, T', printOpts) '`, ' Q '`, ' printBound(BND) '`, '
            printCond(M, COND) '`) ' '\g 'passed. '\o '\n .
 ceq procSolution(M, T, T', Q, BND, COND) = < 0, 1, QIL >
  if metaSearch(M, T, T', COND, Q, BND, 0) == failure /\
     QIL := '\! '\n 'hasSolution '`( metaPrettyPrint(M, T, printOpts) '`, '
            metaPrettyPrint(M, T', printOpts) '`, ' Q '`, ' printBound(BND) '`, '
            printCond(M, COND) '`) ' '\r 'failed. '\o '\n .

 **********************************************************************************
 ********************                noSolution                ********************
 **********************************************************************************

 ceq procProps(M, 'noSolution[T, T', T'', T3, T4]) = UR
  if TSB := solveBubbles(M, T) /\
     TSB' := solveBubbles(M, T') /\
     'token[TI] := T'' /\
     Q := downQid(TI) /\
     (Q == '! or Q == '* or Q == '+) /\
     'token[TI'] := T3 /\
     Q' := downQid(TI') /\
     BND := if Q' == 'unbounded
            then unbounded
            else rat(string(Q'), 10)
            fi /\
     ((T4 == 'bubble[''nil.Qid]) or (solveBubblesCond(addInfoConds(M), T4) :: Condition)) /\
     UR := if T4 == 'bubble[''nil.Qid]
           then noSolution(M, TSB, TSB', Q, BND, nil)
           else noSolution(M, TSB, TSB', Q, BND, solveBubblesCond(addInfoConds(M), T4))
           fi .
 ceq procProps(M, 'noSolution[T, T', T'', T3, T4]) = < 0, 1, QIL' >
  if 'bubble[T1] := T /\
     QIL := downQidList(T1) /\
     not (solveBubbles(M, T) :: Term) /\
     QIL' := '\! '\n '\r 'No 'parse 'for '\o
             '\n QIL '\n .
 ceq procProps(M, 'noSolution[T, T', T'', T3, T4]) = < 0, 1, QIL' >
  if 'bubble[T1] := T' /\
     QIL := downQidList(T1) /\
     not (solveBubbles(M, T) :: Term) /\
     QIL' := '\! '\n '\r 'No 'parse 'for '\o
             '\n QIL '\n .
 ceq procProps(M, 'noSolution[T, T', T'', T3, T4]) = < 0, 1, QIL >
  if 'token[TI] := T'' /\
     Q := downQid(TI) /\
     not (Q == '! or Q == '* or Q == '+) /\
     QIL := '\! '\n '\r 'Invalid 'search 'arrow. '\o '\n .
 ceq procProps(M, 'noSolution[T, T', T'', T3, T4]) = < 0, 1, QIL >
  if 'token[TI'] := T3 /\
     Q' := downQid(TI') /\
     not ((Q' == 'unbounded) or (rat(string(Q'), 10) :: Nat)) /\
     QIL := '\! '\n '\r 'Invalid 'bound. '\o '\n .
 ceq procProps(M, 'noSolution[T, T', T'', T3, T4]) = < 0, 1, QIL >
  if not ((T4 == 'bubble[''nil.Qid]) or (solveBubblesCond(addInfoConds(M), T4) :: Condition)) /\
     QIL := '\! '\n '\r 'Invalid 'condition. '\o '\n .

 op noSolution : Module Term Term Qid Bound Condition -> UnitResult .
 ceq noSolution(M, T, T', Q, BND, COND) = < 1, 0, QIL >
  if metaSearch(M, T, T', COND, Q, BND, 0) == failure /\
     QIL := '\! '\n 'noSolution '`( metaPrettyPrint(M, T, printOpts) '`, '
            metaPrettyPrint(M, T', printOpts) '`, ' Q '`, '
            printCond(M, COND) '`) ' '\g 'passed. '\o '\n .
 ceq noSolution(M, T, T', Q, BND, COND) = < 0, 1, QIL >
  if metaSearch(M, T, T', COND, Q, BND, 0) =/= failure /\
     QIL := '\! '\n 'noSolution '`( metaPrettyPrint(M, T, printOpts) '`, '
            metaPrettyPrint(M, T', printOpts) '`, ' Q '`, '
            printCond(M, COND) '`) ' '\r 'failed. '\o '\n .

 **********************************************************************************
 ********************                assertSort               *********************
 **********************************************************************************

 ceq procProps(M, 'assertSort[T, 'token[T']]) = < 1, 0, QIL >
  if TSB := solveBubbles(M, T) /\
     { T1, S } := metaReduce(M, TSB) /\
     S == downQid(T') /\
     QIL := '\! '\n 'assertSort '`( metaPrettyPrint(M, TSB, printOpts) '`, ' S '`) '
            '\g 'passed. '\o '\n .
 ceq procProps(M, 'assertSort[T, 'token[T']]) = < 0, 1, QIL >
  if TSB := solveBubbles(M, T) /\
     { T1, S } := metaReduce(M, TSB) /\
     Q := downQid(T') /\
     S =/= Q /\
     QIL := '\! '\n 'assertSort '`( metaPrettyPrint(M, TSB, printOpts) '`, ' Q '`) '
            '\r 'failed. '\o '\n
            '\! 'The 'normal 'form 'is '\o metaPrettyPrint(M, T1, printOpts)
            '\n '\! 'Its 'sort 'is '\o S '\n .
 ceq procProps(M, 'assertSort[T, 'token[T']]) = < 0, 1, QIL' >
  if 'bubble[T1] := T /\
     QIL := downQidList(T1) /\
     not (solveBubbles(M, T) :: Term) /\
     QIL' := '\! '\n '\r 'No 'parse 'for '\o
             '\n QIL '\n .

 **********************************************************************************
 ********************                assertLeqSort            *********************
 **********************************************************************************
 ceq procProps(M, 'assertLeqSort[T, 'token[T']]) = < 1, 0, QIL >
  if TSB := solveBubbles(M, T) /\
     { T1, S } := metaReduce(M, TSB) /\
     Q := downQid(T') /\
     Q ; SS := getSorts(M) /\
     sameKind(M, Q, S) /\
     sortLeq(M, S, Q) /\
     QIL := '\! '\n 'assertLeqSort '`( metaPrettyPrint(M, TSB, printOpts) '`, ' Q '`) '
            '\g 'passed. '\o '\n .
 ceq procProps(M, 'assertLeqSort[T, 'token[T']]) = < 0, 1, QIL >
  if TSB := solveBubbles(M, T) /\
     { T1, S } := metaReduce(M, TSB) /\
     Q := downQid(T') /\
     Q ; SS := getSorts(M) /\
     sameKind(M, Q, S) /\
     not sortLeq(M, S, Q) /\
     QIL := '\! '\n 'assertLeqSort '`( metaPrettyPrint(M, TSB, printOpts) '`, Q '`) '
            '\r 'failed. '\o '\n
            '\n '\! 'The 'normal 'form 'is metaPrettyPrint(M, T1, printOpts)
            '\n 'Its 'sort 'is S '\n .
 ceq procProps(M, 'assertLeqSort[T, 'token[T']]) = < 0, 1, QIL >
  if TSB := solveBubbles(M, T) /\
     { T1, S } := metaReduce(M, TSB) /\
     Q := downQid(T') /\
     Q ; SS := getSorts(M) /\
     not sameKind(M, Q, S) /\
     QIL := '\! '\n 'assertLeqSort '`( metaPrettyPrint(M, TSB, printOpts) '`, Q '`) '
            '\r 'failed. '\o '\n
            '\n '\! 'The 'normal 'form 'is metaPrettyPrint(M, T1, printOpts)
            '\n 'Its 'sort 'is S
            '\n 'The 'sorts 'do 'not 'have 'the 'same 'kind. '\n .
 ceq procProps(M, 'assertLeqSort[T, 'token[T']]) = < 0, 1, QIL >
  if TSB := solveBubbles(M, T) /\
     { T1, S } := metaReduce(M, TSB) /\
     Q := downQid(T') /\
     Q notIn getSorts(M) /\
     QIL := '\! '\n 'assertLeqSort '`( metaPrettyPrint(M, TSB, printOpts) '`, Q '`) '
            '\r 'failed. '\o '\n
            '\n '\! 'The Q 'does 'not 'exist. '\n .

 op _notIn_ : Qid SortSet -> Bool .
 eq Q notIn Q ; SS = false .
 eq Q notIn SS = true [owise] .

 eq procProps(M, T) = < 0, 1, nil > [owise print T] .

endfm

eof

 **********************************************************************************
 ********************             assertReachable            **********************
 **********************************************************************************
 ceq procProps(M, 'assertReachable[T, T'], VDS, B, DB, SYS) = [1, 0, QIL, SYS]
  if ATTS := getAtts(SYS) /\
     'bubble[TI] := T /\
     < TI, none > := sub4Atts(M, TI, ATTS) /\
     'bubble[TI'] := T /\
     < TI', none > := sub4Atts(M, TI', ATTS) /\
     T1 := reduce(M, solveBubbles(T, M, B, VDS, DB)) /\
     T2 := reduce(M, solveBubbles(T', M, B, VDS, DB)) /\
     metaSearch(M, T1, T2, nil, '*, unbounded, 0) =/= failure /\
     QIL := '\! '\n 'assertReachable '`( metaPrettyPrint(M, T1, printOpts) '`,
                                         metaPrettyPrint(M, T2, printOpts) '`) '
            '\g 'passed. '\o '\n .
 ceq procProps(M, 'assertReachable[T, T'], VDS, B, DB, SYS) = [1, 0, QIL, SYS]
  if not (getAtts(SYS) :: Term) /\
     T1 := reduce(M, solveBubbles(T, M, B, VDS, DB)) /\
     T2 := reduce(M, solveBubbles(T', M, B, VDS, DB)) /\
     metaSearch(M, T1, T2, nil, '*, unbounded, 0) =/= failure /\
     QIL := '\! '\n 'assertReachable '`( metaPrettyPrint(M, T1, printOpts) '`,
                                         metaPrettyPrint(M, T2, printOpts) '`) '
            '\g 'passed. '\o '\n .
 ceq procProps(M, 'assertReachable['bubble[T], 'bubble[T']], VDS, B, DB, SYS) = [1, 0, QIL, SYS]
  if ATTS := getAtts(SYS) /\
     < TI, SB > := sub4Atts(M, T, ATTS) /\
     < TI1, SB' > := sub4Atts(M, T', ATTS) /\
     ((SB =/= none) or (SB' =/= none)) /\
     TIS := solveBubbles('bubble[TI], M, B, VDS, DB) /\
     TIS' := applySb(TIS, SB) /\
     TIS1 := solveBubbles('bubble[TI1], M, B, VDS, DB) /\
     TIS1' := applySb(TIS1, SB') /\
     T1 := reduce(M, TIS') /\
     T2 := reduce(M, TIS1') /\
     metaSearch(M, T1, T2, nil, '*, unbounded, 0) =/= failure /\
     QIL := '\! '\n 'assertReachable '`( downQidList(T) '`, downQidList(T') '`) '
            '\g 'passed. '\o '\n .
 ceq procProps(M, 'assertReachable[T, T'], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if ATTS := getAtts(SYS) /\
     'bubble[TI] := T /\
     < TI, none > := sub4Atts(M, TI, ATTS) /\
     'bubble[TI'] := T /\
     < TI', none > := sub4Atts(M, TI', ATTS) /\
     T1 := reduce(M, solveBubbles(T, M, B, VDS, DB)) /\
     T2 := reduce(M, solveBubbles(T', M, B, VDS, DB)) /\
     metaSearch(M, T1, T2, nil, '*, unbounded, 0) == failure /\
     QIL := '\! '\n 'assertReachable '`( metaPrettyPrint(M, T1, printOpts) '`,
                                         metaPrettyPrint(M, T2, printOpts) '`) '
            '\r 'failed. '\o '\n .
 ceq procProps(M, 'assertReachable[T, T'], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if not (getAtts(SYS) :: Term) /\
     T1 := reduce(M, solveBubbles(T, M, B, VDS, DB)) /\
     T2 := reduce(M, solveBubbles(T', M, B, VDS, DB)) /\
     metaSearch(M, T1, T2, nil, '*, unbounded, 0) == failure /\
     QIL := '\! '\n 'assertReachable '`( metaPrettyPrint(M, T1, printOpts) '`,
                                         metaPrettyPrint(M, T2, printOpts) '`) '
            '\r 'failed. '\o '\n .
 ceq procProps(M, 'assertReachable['bubble[T], 'bubble[T']], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if ATTS := getAtts(SYS) /\
     < TI, SB > := sub4Atts(M, T, ATTS) /\
     < TI1, SB' > := sub4Atts(M, T', ATTS) /\
     ((SB =/= none) or (SB' =/= none)) /\
     TIS := solveBubbles('bubble[TI], M, B, VDS, DB) /\
     TIS' := applySb(TIS, SB) /\
     TIS1 := solveBubbles('bubble[TI1], M, B, VDS, DB) /\
     TIS1' := applySb(TIS1, SB') /\
     T1 := reduce(M, TIS') /\
     T2 := reduce(M, TIS1') /\
     metaSearch(M, T1, T2, nil, '*, unbounded, 0) == failure /\
     QIL := '\! '\n 'assertReachable '`( downQidList(T) '`, downQidList(T') '`) '
            '\r 'failed. '\o '\n .
 ceq procProps(M, 'assertReachable[T, T'], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if T? := solveBubbles(T, M, B, VDS, DB) /\
     not (T? :: Term) /\
     QIL := ('\n '\r 'Error: '\o getMsg(T?)) .
 ceq procProps(M, 'assertReachable[T, T'], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if T? := solveBubbles(T', M, B, VDS, DB) /\
     not (T? :: Term) /\
     QIL := ('\n '\r 'Error: '\o getMsg(T?)) [owise] .

 **********************************************************************************
 ********************           assertReachableBnd           **********************
 **********************************************************************************
 ceq procProps(M, 'assertReachableBnd[T, T', 'token[T'']], VDS, B, DB, SYS) = [1, 0, QIL, SYS]
  if ATTS := getAtts(SYS) /\
     'bubble[TI] := T /\
     < TI, none > := sub4Atts(M, TI, ATTS) /\
     'bubble[TI'] := T /\
     < TI', none > := sub4Atts(M, TI', ATTS) /\
     T1 := reduce(M, solveBubbles(T, M, B, VDS, DB)) /\
     T2 := reduce(M, solveBubbles(T', M, B, VDS, DB)) /\
     N := rat(string(downQid(T'')), 10) /\
     metaSearch(M, T1, T2, nil, '*, N, 0) =/= failure /\
     QIL := '\! '\n 'assertReachableBnd '`( metaPrettyPrint(M, T1, printOpts) '`,
                                            metaPrettyPrint(M, T2, printOpts) '`,
                                            downQid(T'') '`) ' '\g 'passed. '\o '\n .
 ceq procProps(M, 'assertReachableBnd[T, T', 'token[T'']], VDS, B, DB, SYS) = [1, 0, QIL, SYS]
  if not (getAtts(SYS) :: Term) /\
     T1 := reduce(M, solveBubbles(T, M, B, VDS, DB)) /\
     T2 := reduce(M, solveBubbles(T', M, B, VDS, DB)) /\
     N := rat(string(downQid(T'')), 10) /\
     metaSearch(M, T1, T2, nil, '*, N, 0) =/= failure /\
     QIL := '\! '\n 'assertReachableBnd '`( metaPrettyPrint(M, T1, printOpts) '`,
                                            metaPrettyPrint(M, T2, printOpts) '`,
                                            downQid(T'') '`) ' '\g 'passed. '\o '\n .
 ceq procProps(M, 'assertReachableBnd['bubble[T], 'bubble[T'], 'token[T'']], VDS,
               B, DB, SYS) = [1, 0, QIL, SYS]
  if ATTS := getAtts(SYS) /\
     < TI, SB > := sub4Atts(M, T, ATTS) /\
     < TI1, SB' > := sub4Atts(M, T', ATTS) /\
     ((SB =/= none) or (SB' =/= none)) /\
     TIS := solveBubbles('bubble[TI], M, B, VDS, DB) /\
     TIS' := applySb(TIS, SB) /\
     TIS1 := solveBubbles('bubble[TI1], M, B, VDS, DB) /\
     TIS1' := applySb(TIS1, SB') /\
     T1 := reduce(M, TIS') /\
     T2 := reduce(M, TIS1') /\
     N := rat(string(downQid(T'')), 10) /\
     metaSearch(M, T1, T2, nil, '*, N, 0) =/= failure /\
     QIL := '\! '\n 'assertReachableBnd '`( downQidList(T) '`, downQidList(T') '`,
                                            downQid(T'') '`) ' '\g 'passed. '\o '\n .
 ceq procProps(M, 'assertReachableBnd[T, T', 'token[T'']], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if ATTS := getAtts(SYS) /\
     'bubble[TI] := T /\
     < TI, none > := sub4Atts(M, TI, ATTS) /\
     'bubble[TI'] := T /\
     < TI', none > := sub4Atts(M, TI', ATTS) /\
     T1 := reduce(M, solveBubbles(T, M, B, VDS, DB)) /\
     T2 := reduce(M, solveBubbles(T', M, B, VDS, DB)) /\
     N := rat(string(downQid(T'')), 10) /\
     metaSearch(M, T1, T2, nil, '*, N, 0) == failure /\
     QIL := '\! '\n 'assertReachableBnd '`( metaPrettyPrint(M, T1, printOpts) '`,
                                            metaPrettyPrint(M, T2, printOpts) '`,
                                            downQid(T'') '`) ' '\r 'failed. '\o '\n .
 ceq procProps(M, 'assertReachableBnd[T, T', 'token[T'']], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if not (getAtts(SYS) :: Term) /\
     T1 := reduce(M, solveBubbles(T, M, B, VDS, DB)) /\
     T2 := reduce(M, solveBubbles(T', M, B, VDS, DB)) /\
     N := rat(string(downQid(T'')), 10) /\
     metaSearch(M, T1, T2, nil, '*, N, 0) == failure /\
     QIL := '\! '\n 'assertReachableBnd '`( metaPrettyPrint(M, T1, printOpts) '`,
                                            metaPrettyPrint(M, T2, printOpts) '`,
                                            downQid(T'') '`) ' '\r 'failed. '\o '\n .
 ceq procProps(M, 'assertReachableBnd['bubble[T], 'bubble[T'], 'token[T'']], VDS,
               B, DB, SYS) = [0, 1, QIL, SYS]
  if ATTS := getAtts(SYS) /\
     < TI, SB > := sub4Atts(M, T, ATTS) /\
     < TI1, SB' > := sub4Atts(M, T', ATTS) /\
     ((SB =/= none) or (SB' =/= none)) /\
     TIS := solveBubbles('bubble[TI], M, B, VDS, DB) /\
     TIS' := applySb(TIS, SB) /\
     TIS1 := solveBubbles('bubble[TI1], M, B, VDS, DB) /\
     TIS1' := applySb(TIS1, SB') /\
     T1 := reduce(M, TIS') /\
     T2 := reduce(M, TIS1') /\
     N := rat(string(downQid(T'')), 10) /\
     metaSearch(M, T1, T2, nil, '*, N, 0) == failure /\
     QIL := '\! '\n 'assertReachableBnd '`( downQidList(T) '`, downQidList(T') '`,
                                            downQid(T'') '`) ' '\r 'failed. '\o '\n .
 ceq procProps(M, 'assertReachableBnd[T, T', 'token[T'']], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if not (rat(string(downQid(T'')), 10) :: Nat) /\
     QIL := ('\n '\r 'Error: '\o 'Not 'a 'number) .
 ceq procProps(M, 'assertReachableBnd[T, T', T''], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if T? := solveBubbles(T, M, B, VDS, DB) /\
     not (T? :: Term) /\
     QIL := ('\n '\r 'Error: '\o getMsg(T?)) [owise] .

 **********************************************************************************
 **********************************************************************************
 ********************          AUXILIARY FUNCTIONS           **********************
 **********************************************************************************
 **********************************************************************************

 op applySb : Term Substitution -> Term .
 eq applySb(Q[TL], SB) = Q[applySb*(TL, SB)] .
 eq applySb(C, SB) = C .
 eq applySb(V, V <- T ; SB) = T .
 eq applySb(V, SB) = V [owise] .

 op applySb* : TermList Substitution -> TermList .
 eq applySb*(empty, SB) = empty .
 eq applySb*((T, TL), SB) = applySb(T, SB), applySb*(TL, SB) .
endfm

