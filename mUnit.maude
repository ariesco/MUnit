fmod UNIT-RESULT is
 pr QID-LIST .

 sort UnitResult .

 *** Correct test, failed tests, Tests info
 op <_,_,_> : Nat Nat QidList -> UnitResult [ctor] .
endfm

fmod AUX is
 pr META-LEVEL .

 vars TL TL' : TermList .
 var  COND : Condition .
 var  Ct : Constant .
 vars T T' : Term .
 var  M : Module .
 var  Ty : Type .
 var  QI : Qid .

 op printOpts : -> PrintOptionSet .
 eq printOpts = mixfix number rat format .

 op downQid : Term -> [Qid] .
 eq downQid(Ct)
    = qid(substr(string(getName(Ct)), 1, length(string(getName(Ct))))) .

 op downQidList : Term -> [QidList] .
 eq downQidList('nil.TypeList) = nil .
 eq downQidList('__[TL]) = downQidList(TL) .
 ceq downQidList((TL, TL')) = (downQidList(TL) downQidList(TL'))
  if TL =/= empty /\ TL' =/= empty .
 eq downQidList(QI) = downQid(QI) [owise] .

 op reduce : Module Term -> Term .
 eq reduce(M, T) = getTerm(metaReduce(M, T)) .

 op rewrite : Module Term -> Term .
 eq rewrite(M, T) = getTerm(metaRewrite(M, T, unbounded)) .

 op printCond : Module Condition ~> QidList .
 eq printCond(M, nil) = 'nil .
 eq printCond(M, COND) = $printCond(M, COND) [owise] .

 op $printCond : Module Condition ~> QidList .
 eq $printCond(M, nil) = nil .
 eq $printCond(M, T = T' /\ COND) = metaPrettyPrint(M, T, printOpts) '=
                                    metaPrettyPrint(M, T', printOpts) .
 eq $printCond(M, T := T' /\ COND) = metaPrettyPrint(M, T, printOpts) ':=
                                     metaPrettyPrint(M, T', printOpts) .
 eq $printCond(M, T => T' /\ COND) = metaPrettyPrint(M, T, printOpts) '=>
                                     metaPrettyPrint(M, T', printOpts) .
 eq $printCond(M, T : Ty /\ COND) = metaPrettyPrint(M, T, printOpts) ': Ty .
endfm

fmod MUNIT-COMMAND-PROCESSING is
 pr UNIT-RESULT .
 pr AUX .

 vars T T' T'' T''' T1 T2 T3 T4 TSB TSB' TSB'' TI TI' TI1 TIS TIS' TIS1 TIS1' MSG : Term .
 vars QIL QIL' QILI QILI' : QidList .
 vars TL TL' TL'' : TermList .
 vars SB SB' : Substitution .
 vars St St' St'' : String .
 vars VDS ODS : OpDeclSet .
 var  COND? : [Condition] .
 vars N N' N1 N1' : Nat .
 var  COND : Condition .
 var  UR : UnitResult .
 vars Ty Ty' : Type .
 var  AtS : AttrSet .
 var  V : Variable .
 var  SS : SortSet .
 var  C : Constant .
 var  BND : Bound .
 var  T? : [Term] .
 var  M : Module .
 vars Q Q' : Qid .
 var  S : Sort .
 var  B : Bool .

 op procMUnit : Term -> UnitResult .
 ceq procMUnit('munit_is_endu['token[T], T']) = procMUnit(Q, T')
  if Q := downTerm(T, 'error) [print Q] .

 op procMUnit : Qid Term -> UnitResult .
 ceq procMUnit(Q, T) = procProps(M, T)
  if M := upModule(Q, false) .
 eq procMUnit(Q, T) = < 0, 0, '\n '\r '\! 'Error: '\o 'The
                              'module 'is 'not 'loaded. '\n > [owise] .

 op procProps : Module Term -> UnitResult .
 ceq procProps(M, '__[T, T']) = < N + N', N1 + N1', QIL QIL' >
  if < N, N1, QIL > := procProps(M, T) /\
     < N', N1', QIL' > := procProps(M, T') .

 *********************************************************************************
 ********************                assertTrue               ********************
 *********************************************************************************
 ceq procProps(M, 'assertTrue[T]) = < 1, 0, QIL' >
  if 'bubble[T1] := T /\
     QIL := downQidList(T1) /\
     {T', Ty} := metaParse(M, QIL, anyType) /\
     reduce(M, T') == 'true.Bool /\
     QIL' := '\! '\n 'assertTrue '`( metaPrettyPrint(M, T', printOpts) '`) '
             '\g 'passed. '\o '\n .
 ceq procProps(M, 'assertTrue[T]) = < 0, 1, QIL' >
  if 'bubble[T1] := T /\
     QIL := downQidList(T1) /\
     {T', Ty} := metaParse(M, QIL, anyType) /\
     T2 := reduce(M, T') /\
     T2 =/= 'true.Bool /\
     QIL' := '\! '\n 'assertTrue '`( metaPrettyPrint(M, T', printOpts) '`) '
             '\r 'failed. '\o '\n
             '\! 'Term 'reduced 'to metaPrettyPrint(M, T2, printOpts) '\o '\n .
 ceq procProps(M, 'assertTrue[T]) = < 0, 1, QIL' >
  if 'bubble[T1] := T /\
     QIL := downQidList(T1) /\
     not (metaParse(M, QIL, anyType) :: ResultPair) /\
     QIL' := '\! '\n '\r 'No 'parse 'for '\o
             '\n 'assertTrue '`( QIL '`) '\n .

 **********************************************************************************
 ********************                assertFalse               ********************
 **********************************************************************************
 ceq procProps(M, 'assertFalse[T]) = < 1, 0, QIL' >
  if 'bubble[T1] := T /\
     QIL := downQidList(T1) /\
     {T', Ty} := metaParse(M, QIL, anyType) /\
     reduce(M, T') == 'true.Bool /\
     QIL' := '\! '\n 'assertFalse '`( metaPrettyPrint(M, T', printOpts) '`) '
             '\g 'passed. '\o '\n .
 ceq procProps(M, 'assertFalse[T]) = < 0, 1, QIL' >
  if 'bubble[T1] := T /\
     QIL := downQidList(T1) /\
     {T', Ty} := metaParse(M, QIL, anyType) /\
     T2 := reduce(M, T') /\
     T2 =/= 'true.Bool /\
     QIL' := '\! '\n 'assertFalse '`( metaPrettyPrint(M, T', printOpts) '`) '
             '\r 'failed. '\o '\n
             '\! 'Term 'reduced 'to metaPrettyPrint(M, T2, printOpts) '\o '\n .
 ceq procProps(M, 'assertFalse[T]) = < 0, 1, QIL' >
  if 'bubble[T1] := T /\
     QIL := downQidList(T1) /\
     not (metaParse(M, QIL, anyType) :: ResultPair) /\
     QIL' := '\! '\n '\r 'No 'parse 'for '\o
             '\n 'assertFalse '`( QIL '`)  '\n .

 *********************************************************************************
 *******************                assertTrueMsg             ********************
 *********************************************************************************
 ceq procProps(M, 'assertTrueMsg[T, 'token[MSG]]) = < 1, 0, QIL' >
  if 'bubble[T1] := T /\
     QIL := downQidList(T1) /\
     {T', Ty} := metaParse(M, QIL, anyType) /\
     reduce(M, T') == 'true.Bool /\
     QIL' := '\! '\n 'assertTrue '`( metaPrettyPrint(M, T', printOpts) '`) '
             '\g 'passed. '\o '\n
            ' '---> ' downQid(MSG) '\n .
 ceq procProps(M, 'assertTrueMsg[T, 'token[MSG]]) = < 0, 1, QIL' >
  if 'bubble[T1] := T /\
     QIL := downQidList(T1) /\
     {T', Ty} := metaParse(M, QIL, anyType) /\
     T2 := reduce(M, T') /\
     T2 =/= 'true.Bool /\
     QIL' := '\! '\n 'assertTrue '`( metaPrettyPrint(M, T', printOpts) '`) '
             '\r 'failed. '\o '\n
             '\! 'Term 'reduced 'to metaPrettyPrint(M, T2, printOpts) '\o '\n
             ' '---> ' downQid(MSG) '\n .
 ceq procProps(M, 'assertTrueMsg[T, 'token[MSG]]) = < 0, 1, QIL' >
  if 'bubble[T1] := T /\
     QIL := downQidList(T1) /\
     not (metaParse(M, QIL, anyType) :: ResultPair) /\
     QIL' := '\! '\n '\r 'No 'parse 'for '\o
             '\n 'assertTrue '`( QIL '`) '\n
             ' '---> ' downQid(MSG) '\n .

 **********************************************************************************
 ********************                assertEqual               ********************
 **********************************************************************************
 ceq procProps(M, 'assertEqual[T, T']) = < 1, 0, QIL >
  if 'bubble[TI] := T /\
     QILI := downQidList(TI) /\
     'bubble[TI'] := T' /\
     QILI' := downQidList(TI') /\
     {TSB, Ty} := metaParse(M, QILI, anyType) /\
     {TSB', Ty'} := metaParse(M, QILI', anyType) /\
     reduce(M, TSB) == reduce(M, TSB') /\
     QIL := '\! '\n 'assertEqual '`( metaPrettyPrint(M, TSB, printOpts) '`,
            metaPrettyPrint(M, TSB', printOpts) '`) ' '\g 'passed. '\o '\n .
 ceq procProps(M, 'assertEqual[T, T']) = < 0, 1, QIL >
  if 'bubble[TI] := T /\
     QILI := downQidList(TI) /\
     'bubble[TI'] := T' /\
     QILI' := downQidList(TI') /\
     {TSB, Ty} := metaParse(M, QILI, anyType) /\
     {TSB', Ty'} := metaParse(M, QILI', anyType) /\
     T1 := reduce(M, TSB) /\
     T2 := reduce(M, TSB') /\
     T1 =/= T2 /\
     QIL := '\! '\n 'assertEqual '`( metaPrettyPrint(M, TSB, printOpts) '`,
            metaPrettyPrint(M, TSB', printOpts) '`) ' '\r 'failed. '\o '\n
            '\! 'First 'term 'reduced 'to metaPrettyPrint(M, T1, printOpts) '\o '\n
            '\! 'Second 'term 'reduced 'to metaPrettyPrint(M, T2, printOpts) '\o '\n .


 eq procProps(M, T) = < 0, 1, nil > [owise print T] .

endfm

eof
 ceq procProps(M, 'assertEqual[T, T'], VDS, B, DB, SYS) = [1, 0, QIL, SYS]
  if not (getAtts(SYS) :: Term) /\
     TSB := solveBubbles(T, M, B, VDS, DB) /\
     TSB' := solveBubbles(T', M, B, VDS, DB) /\
     T1 := reduce(M, TSB) /\
     T1 := reduce(M, TSB') /\
     QIL := '\! '\n 'assertEqual '`( metaPrettyPrint(M, TSB, printOpts) '`,
            metaPrettyPrint(M, TSB', printOpts) '`) ' '\g 'passed. '\o '\n .
 ceq procProps(M, 'assertEqual[T, T'], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if 'bubble[TI] := T /\
     ATTS := getAtts(SYS) /\
     < TI, none > := sub4Atts(M, TI, ATTS) /\
     'bubble[TI'] := T' /\
     < TI', none > := sub4Atts(M, TI', ATTS) /\
     TSB := solveBubbles(T, M, B, VDS, DB) /\
     TSB' := solveBubbles(T', M, B, VDS, DB) /\
     T1 := reduce(M, TSB) /\
     T2 := reduce(M, TSB') /\
     T1 =/= T2 /\
     QIL := '\! '\n 'assertEqual '`( metaPrettyPrint(M, TSB, printOpts) '`,
            metaPrettyPrint(M, TSB', printOpts) '`) ' '\r 'failed. '\o '\n
            '\! 'First 'term 'reduced 'to metaPrettyPrint(M, T1, printOpts) '\o '\n
            '\! 'Second 'term 'reduced 'to metaPrettyPrint(M, T2, printOpts) '\o '\n .
 ceq procProps(M, 'assertEqual[T, T'], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if not (getAtts(SYS) :: Term) /\
     TSB := solveBubbles(T, M, B, VDS, DB) /\
     TSB' := solveBubbles(T', M, B, VDS, DB) /\
     T1 := reduce(M, TSB) /\
     T2 := reduce(M, TSB') /\
     T1 =/= T2 /\
     QIL := '\! '\n 'assertEqual '`( metaPrettyPrint(M, TSB, printOpts) '`,
            metaPrettyPrint(M, TSB', printOpts) '`) ' '\r 'failed. '\o '\n
            '\! 'First 'term 'reduced 'to metaPrettyPrint(M, T1, printOpts) '\o '\n
            '\! 'Second 'term 'reduced 'to metaPrettyPrint(M, T2, printOpts) '\o '\n .
 ceq procProps(M, 'assertEqual['bubble[T], 'bubble[T']], VDS, B, DB, SYS) = [1, 0, QIL, SYS]
  if ATTS := getAtts(SYS) /\
     < TI, SB > := sub4Atts(M, T, ATTS) /\
     < TI1, SB' > := sub4Atts(M, T', ATTS) /\
     ((SB =/= none) or (SB' =/= none)) /\
     TIS := solveBubbles('bubble[TI], M, B, VDS, DB) /\
     TIS' := applySb(TIS, SB) /\
     TIS1 := solveBubbles('bubble[TI1], M, B, VDS, DB) /\
     TIS1' := applySb(TIS1, SB') /\
     T1 := reduce(M, TIS') /\
     T1 := reduce(M, TIS1') /\
     QIL := '\! '\n 'assertEqual '`( downQidList(T) '`, downQidList(T') '`) '
            '\g 'passed. '\o '\n .
 ceq procProps(M, 'assertEqual['bubble[T], 'bubble[T']], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if ATTS := getAtts(SYS) /\
     < TI, SB > := sub4Atts(M, T, ATTS) /\
     < TI1, SB' > := sub4Atts(M, T', ATTS) /\
     ((SB =/= none) or (SB' =/= none)) /\
     TIS := solveBubbles('bubble[TI], M, B, VDS, DB) /\
     TIS' := applySb(TIS, SB) /\
     TIS1 := solveBubbles('bubble[TI1], M, B, VDS, DB) /\
     TIS1' := applySb(TIS1, SB') /\
     T1 := reduce(M, TIS') /\
     T2 := reduce(M, TIS1') /\
     T1 =/= T2 /\
     QIL := '\! '\n 'assertEqual '`( downQidList(T) '`, downQidList(T') '`) '
            '\r 'failed. '\o '\n
            '\! 'First 'term 'reduced 'to metaPrettyPrint(M, T1, printOpts) '\o '\n
            '\! 'Second 'term 'reduced 'to metaPrettyPrint(M, T2, printOpts) '\o '\n .
 ceq procProps(M, 'assertEqual[T, T'], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if T? := solveBubbles(T, M, B, VDS, DB) /\
     not (T? :: Term) /\
     QIL := ('\n '\r 'Error: '\o getMsg(T?)) .
 ceq procProps(M, 'assertEqual[T, T'], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if T? := solveBubbles(T', M, B, VDS, DB) /\
     not (T? :: Term) /\
     QIL := ('\n '\r 'Error: '\o getMsg(T?)) [owise] .

 **************************************************************************************
 ********************                assertDifferent               ********************
 **************************************************************************************
 ceq procProps(M, 'assertDifferent[T, T'], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if 'bubble[TI] := T /\
     ATTS := getAtts(SYS) /\
     < TI, none > := sub4Atts(M, TI, ATTS) /\
     'bubble[TI'] := T /\
     < TI', none > := sub4Atts(M, TI', ATTS) /\
     TSB := solveBubbles(T, M, B, VDS, DB) /\
     TSB' := solveBubbles(T', M, B, VDS, DB) /\
     T1 := reduce(M, TSB) /\
     T1 := reduce(M, TSB') /\
     QIL := '\! '\n 'assertDifferent '`( metaPrettyPrint(M, TSB, printOpts) '`,
            metaPrettyPrint(M, TSB', printOpts) '`) ' '\r 'failed. '\o '\n .
 ceq procProps(M, 'assertDifferent[T, T'], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if not (getAtts(SYS) :: Term) /\
     TSB := solveBubbles(T, M, B, VDS, DB) /\
     TSB' := solveBubbles(T', M, B, VDS, DB) /\
     T1 := reduce(M, TSB) /\
     T1 := reduce(M, TSB') /\
     QIL := '\! '\n 'assertDifferent '`( metaPrettyPrint(M, TSB, printOpts) '`,
            metaPrettyPrint(M, TSB', printOpts) '`) ' '\r 'failed. '\o '\n .
 ceq procProps(M, 'assertDifferent[T, T'], VDS, B, DB, SYS) = [1, 0, QIL, SYS]
  if 'bubble[TI] := T /\
     ATTS := getAtts(SYS) /\
     < TI, none > := sub4Atts(M, TI, ATTS) /\
     'bubble[TI'] := T /\
     < TI', none > := sub4Atts(M, TI', ATTS) /\
     TSB := solveBubbles(T, M, B, VDS, DB) /\
     TSB' := solveBubbles(T', M, B, VDS, DB) /\
     T1 := reduce(M, TSB) /\
     T2 := reduce(M, TSB') /\
     T1 =/= T2 /\
     QIL := '\! '\n 'assertDifferent '`( metaPrettyPrint(M, TSB, printOpts) '`,
            metaPrettyPrint(M, TSB', printOpts) '`) ' '\g 'passed. '\o '\n .
 ceq procProps(M, 'assertDifferent[T, T'], VDS, B, DB, SYS) = [1, 0, QIL, SYS]
  if not (getAtts(SYS) :: Term) /\
     TSB := solveBubbles(T, M, B, VDS, DB) /\
     TSB' := solveBubbles(T', M, B, VDS, DB) /\
     T1 := reduce(M, TSB) /\
     T2 := reduce(M, TSB') /\
     T1 =/= T2 /\
     QIL := '\! '\n 'assertDifferent '`( metaPrettyPrint(M, TSB, printOpts) '`,
            metaPrettyPrint(M, TSB', printOpts) '`) ' '\g 'passed. '\o '\n .
 ceq procProps(M, 'assertDifferent['bubble[T], 'bubble[T']], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if ATTS := getAtts(SYS) /\
     < TI, SB > := sub4Atts(M, T, ATTS) /\
     < TI1, SB' > := sub4Atts(M, T', ATTS) /\
     ((SB =/= none) or (SB' =/= none)) /\
     TIS := solveBubbles('bubble[TI], M, B, VDS, DB) /\
     TIS' := applySb(TIS, SB) /\
     TIS1 := solveBubbles('bubble[TI1], M, B, VDS, DB) /\
     TIS1' := applySb(TIS1, SB') /\
     T1 := reduce(M, TIS') /\
     T1 := reduce(M, TIS1') /\
     QIL := '\! '\n 'assertDifferent '`( downQidList(T) '`, downQidList(T') '`) '
            '\r 'failed. '\o '\n
            '\! 'Terms 'reduced 'to metaPrettyPrint(M, T1, printOpts) '\o '\n .
 ceq procProps(M, 'assertDifferent['bubble[T], 'bubble[T']], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if ATTS := getAtts(SYS) /\
     < TI, SB > := sub4Atts(M, T, ATTS) /\
     < TI1, SB' > := sub4Atts(M, T', ATTS) /\
     ((SB =/= none) or (SB' =/= none)) /\
     TIS := solveBubbles('bubble[TI], M, B, VDS, DB) /\
     TIS' := applySb(TIS, SB) /\
     TIS1 := solveBubbles('bubble[TI1], M, B, VDS, DB) /\
     TIS1' := applySb(TIS1, SB') /\
     T1 := reduce(M, TIS') /\
     T2 := reduce(M, TIS1') /\
     T1 =/= T2 /\
     QIL := '\! '\n 'assertDifferent '`( downQidList(T) '`, downQidList(T') '`) '
            '\g 'passed. '\o '\n .
 ceq procProps(M, 'assertDifferent[T, T'], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if T? := solveBubbles(T, M, B, VDS, DB) /\
     not (T? :: Term) /\
     QIL := ('\n '\r 'Error: '\o getMsg(T?)) .
 ceq procProps(M, 'assertDifferent[T, T'], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if T? := solveBubbles(T', M, B, VDS, DB) /\
     not (T? :: Term) /\
     QIL := ('\n '\r 'Error: '\o getMsg(T?)) [owise] .

 **********************************************************************************
 ********************                hasSolution               ********************
 **********************************************************************************
 ceq procProps(M, 'hasSolution[T, T', T'', T3, T4], VDS, B, DB, SYS) = UR
  if TSB := solveBubbles(T, M, B, VDS, DB) /\
     TSB' := solveBubbles(T', M, B, VDS, DB) /\
     'token[TI] := T'' /\
     Q := downQid(TI) /\
     (Q == '! or Q == '* or Q == '+) /\
     'token[TI'] := T3 /\
     Q' := downQid(TI') /\
     BND := if Q' == 'unbounded
            then unbounded
            else rat(string(Q'), 10)
            fi /\
     UR := if T4 == 'bubble[''nil.Qid]
           then procSolution(M, TSB, TSB', Q, BND, nil, SYS)
           else procSolution(M, TSB, TSB', Q, BND, solveBubblesCond(T4, M, addInfoConds(M), B, VDS, DB), SYS)
           fi .

 op procSolution : Module Term Term Qid Bound [Condition] Term -> UnitResult .
 ceq procSolution(M, T, T', Q, BND, COND, SYS) = [1, 0, QIL, SYS]
  if metaSearch(M, T, T', COND, Q, BND, 0) =/= failure /\
     QIL := '\! '\n 'hasSolution '`( metaPrettyPrint(M, T, printOpts) '`, '
            metaPrettyPrint(M, T', printOpts) '`, ' Q '`, '
            printCond(M, COND) '`) ' '\g 'passed. '\o '\n .
 ceq procSolution(M, T, T', Q, BND, COND, SYS) = [0, 1, QIL, SYS]
  if metaSearch(M, T, T', COND, Q, BND, 0) == failure /\
     QIL := '\! '\n 'hasSolution '`( metaPrettyPrint(M, T, printOpts) '`, '
            metaPrettyPrint(M, T', printOpts) '`, ' Q '`, '
            printCond(M, COND) '`) ' '\r 'failed. '\o '\n .

 **********************************************************************************
 ********************                noSolution                ********************
 **********************************************************************************
 ceq procProps(M, 'noSolution[T, T', T'', T3, T4], VDS, B, DB, SYS) = UR
  if TSB := solveBubbles(T, M, B, VDS, DB) /\
     TSB' := solveBubbles(T', M, B, VDS, DB) /\
     'token[TI] := T'' /\
     Q := downQid(TI) /\
     (Q == '! or Q == '* or Q == '+) /\
     'token[TI'] := T3 /\
     Q' := downQid(TI') /\
     BND := if Q' == 'unbounded
            then unbounded
            else rat(string(Q'), 10)
            fi /\
     UR := if T4 == 'bubble[''nil.Qid]
           then noSolution(M, TSB, TSB', Q, BND, nil, SYS)
           else noSolution(M, TSB, TSB', Q, BND, solveBubblesCond(T4, M, addInfoConds(M), B, VDS, DB), SYS)
           fi .

 op noSolution : Module Term Term Qid Bound [Condition] Term -> UnitResult .
 ceq noSolution(M, T, T', Q, BND, COND, SYS) = [1, 0, QIL, SYS]
  if metaSearch(M, T, T', COND, Q, BND, 0) == failure /\
     QIL := '\! '\n 'noSolution '`( metaPrettyPrint(M, T, printOpts) '`, '
            metaPrettyPrint(M, T', printOpts) '`, ' Q '`, '
            printCond(M, COND) '`) ' '\g 'passed. '\o '\n .
 ceq procSolution(M, T, T', Q, BND, COND, SYS) = [0, 1, QIL, SYS]
  if metaSearch(M, T, T', COND, Q, BND, 0) =/= failure /\
     QIL := '\! '\n 'noSolution '`( metaPrettyPrint(M, T, printOpts) '`, '
            metaPrettyPrint(M, T', printOpts) '`, ' Q '`, '
            printCond(M, COND) '`) ' '\r 'failed. '\o '\n .

 *********************************************************************************
 ***********************                loop               ***********************
 *********************************************************************************
 ceq procProps(M, 'loop['token[T]], VDS, B, DB, SYS) = [0, 0, QIL, T'']
  if Q := downQid(T) /\
     T' := qid(string(Q) + ".System") /\
     T'' := rewrite(M, T') /\
     QIL := '\n '\! 'loop '\b Q '\o '\! 'started. '\o '\n .
 ceq procProps(M, 'loop['token[T]], VDS, B, DB, SYS) = [0, 0, QIL, SYS]
  if Q := downQid(T) /\
     T' := qid(string(Q) + ".System") /\
     not (metaRewrite(M, T', unbounded) :: ResultPair) /\
     QIL := '\n '\! '\r 'loop '\b Q '\o '\! '\r 'failed. '\o '\n .

 ************************************************************************************
 ***********************                command               ***********************
 ************************************************************************************
 ceq procProps(M, 'command['bubble[T]], VDS, B, DB, SYS) = [0, 0, QIL', SYS'']
  if QIL := downQidList(T) /\
     T' := upTerm(QIL) /\
     SYS' := sysInput(SYS, T') /\
     SYS'' := rewrite(M, SYS') /\
     QIL' := '\n '\! 'command '\b ' '`( QIL '`) ' '\o '\! 'executed. '\o '\n .
 ceq procProps(M, 'command['bubble[T]], VDS, B, DB, SYS) = [0, 0, QIL', SYS]
  if QIL := downQidList(T) /\
     T' := upTerm(QIL) /\
     SYS' := sysInput(SYS, T') /\
     not (metaRewrite(M, SYS', unbounded) :: ResultPair) /\
     QIL' := '\n '\! '\r 'command '\b ' '`( QIL '`) ' '\o '\! '\r 'failed. '\o '\n .

 **********************************************************************************
 ********************                assertSort               *********************
 **********************************************************************************
 ceq procProps(M, 'assertSort[T, 'token[T']], VDS, B, DB, SYS) = [1, 0, QIL, SYS]
  if 'bubble[TI] := T /\
     ATTS := getAtts(SYS) /\
     < TI, none > := sub4Atts(M, TI, ATTS) /\
     TSB := solveBubbles(T, M, B, VDS, DB) /\
     { T1, S } := metaReduce(M, TSB) /\
     S := downQid(T') /\
     QIL := '\! '\n 'assertSort '`( metaPrettyPrint(M, TSB, printOpts) '`, S '`) '
            '\g 'passed. '\o '\n .
 ceq procProps(M, 'assertSort[T, 'token[T']], VDS, B, DB, SYS) = [1, 0, QIL, SYS]
  if not (getAtts(SYS) :: Term) /\
     TSB := solveBubbles(T, M, B, VDS, DB) /\
     { T1, S } := metaReduce(M, TSB) /\
     S := downQid(T') /\
     QIL := '\! '\n 'assertSort '`( metaPrettyPrint(M, TSB, printOpts) '`, S '`) '
            '\g 'passed. '\o '\n .
 ceq procProps(M, 'assertSort['bubble[T], 'token[T']], VDS, B, DB, SYS) = [1, 0, QIL, SYS]
  if ATTS := getAtts(SYS) /\
     < TI, SB > := sub4Atts(M, T, ATTS) /\
     SB =/= none /\
     TIS := solveBubbles('bubble[TI], M, B, VDS, DB) /\
     TIS' := applySb(TIS, SB) /\
     { T1, S } := metaReduce(M, TIS') /\
     S := downQid(T') /\
     QIL := '\! '\n 'assertSort '`( downQidList(T) '`, S '`) '
            '\g 'passed. '\o '\n .
 ceq procProps(M, 'assertSort[T, 'token[T']], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if 'bubble[TI] := T /\
     ATTS := getAtts(SYS) /\
     < TI, none > := sub4Atts(M, TI, ATTS) /\
     TSB := solveBubbles(T, M, B, VDS, DB) /\
     { T1, S } := metaReduce(M, TSB) /\
     Q := downQid(T') /\
     Q ; SS := getSorts(M) /\
     S =/= Q /\
     not sortLeq(M, S, Q) /\
     QIL := '\! '\n 'assertSort '`( metaPrettyPrint(M, TSB, printOpts) '`, Q '`) '
            '\r 'failed. '\o '\n
            '\! 'The 'normal 'form 'is '\o metaPrettyPrint(M, T1, printOpts)
            '\n '\! 'Its 'sort 'is '\o S '\n .
 ceq procProps(M, 'assertSort[T, 'token[T']], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if not (getAtts(SYS) :: Term) /\
     TSB := solveBubbles(T, M, B, VDS, DB) /\
     { T1, S } := metaReduce(M, TSB) /\
     Q := downQid(T') /\
     Q ; SS := getSorts(M) /\
     sameKind(M, Q, S) /\
     S =/= Q /\
     QIL := '\! '\n 'assertSort '`( metaPrettyPrint(M, TSB, printOpts) '`, Q '`) '
            '\r 'failed. '\o '\n
            '\! 'The 'normal 'form 'is '\o metaPrettyPrint(M, T1, printOpts)
            '\n '\! 'Its 'sort 'is '\o S '\n .
 ceq procProps(M, 'assertSort['bubble[T], 'token[T']], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if ATTS := getAtts(SYS) /\
     < TI, SB > := sub4Atts(M, T, ATTS) /\
     SB =/= none /\
     TIS := solveBubbles('bubble[TI], M, B, VDS, DB) /\
     TIS' := applySb(TIS, SB) /\
     { T1, S } := metaReduce(M, TIS') /\
     Q := downQid(T') /\
     Q ; SS := getSorts(M) /\
     sameKind(M, Q, S) /\
     S =/= Q /\
     QIL := '\! '\n 'assertSort '`( downQidList(T) '`, Q '`) ' '\r 'failed. '\o '\n
            '\! 'The 'normal 'form 'is ' '\o metaPrettyPrint(M, T1, printOpts)
            '\n '\! 'Its 'sort 'is '\o S '\n .
 ceq procProps(M, 'assertSort[T, 'token[T']], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if 'bubble[TI] := T /\
     ATTS := getAtts(SYS) /\
     < TI, none > := sub4Atts(M, TI, ATTS) /\
     TSB := solveBubbles(T, M, B, VDS, DB) /\
     { T1, S } := metaReduce(M, TSB) /\
     Q := downQid(T') /\
     Q ; SS := getSorts(M) /\
     not sameKind(M, Q, S) /\
     QIL := '\! '\n 'assertSort '`( metaPrettyPrint(M, TSB, printOpts) '`, Q '`) '
            '\r 'failed. '\o '\n
            '\! 'The 'normal 'form 'is ' '\o metaPrettyPrint(M, T1, printOpts)
            '\n '\! 'Its 'sort 'is '\o S '\n .
 ceq procProps(M, 'assertSort[T, 'token[T']], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if not (getAtts(SYS) :: Term) /\
     TSB := solveBubbles(T, M, B, VDS, DB) /\
     { T1, S } := metaReduce(M, TSB) /\
     Q := downQid(T') /\
     Q ; SS := getSorts(M) /\
     not sameKind(M, Q, S) /\
     QIL := '\! '\n 'assertSort '`( metaPrettyPrint(M, TSB, printOpts) '`, Q '`) '
            '\r 'failed. '\o '\n
            '\! 'The 'normal 'form 'is ' '\o metaPrettyPrint(M, T1, printOpts)
            '\n '\! 'Its 'sort 'is '\o S '\n .
 ceq procProps(M, 'assertSort['bubble[T], 'token[T']], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if ATTS := getAtts(SYS) /\
     < TI, SB > := sub4Atts(M, T, ATTS) /\
     SB =/= none /\
     TIS := solveBubbles('bubble[TI], M, B, VDS, DB) /\
     TIS' := applySb(TIS, SB) /\
     { T1, S } := metaReduce(M, TIS') /\
     Q := downQid(T') /\
     Q ; SS := getSorts(M) /\
     not sameKind(M, Q, S) /\
     QIL := '\! '\n 'assertSort '`( downQidList(T) '`, Q '`) ' '\r 'failed. '\o '\n
            '\! 'The 'normal 'form 'is ' '\o metaPrettyPrint(M, T1, printOpts)
            '\n '\! 'Its 'sort 'is '\o S '\n .
 ceq procProps(M, 'assertSort[T, 'token[T']], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if T? := solveBubbles(T, M, B, VDS, DB) /\
     not (T? :: Term) /\
     QIL := ('\n '\r 'Error: '\o getMsg(T?)) [owise] .

 **********************************************************************************
 ********************                assertLeqSort            *********************
 **********************************************************************************
 ceq procProps(M, 'assertLeqSort[T, 'token[T']], VDS, B, DB, SYS) = [1, 0, QIL, SYS]
  if 'bubble[TI] := T /\
     ATTS := getAtts(SYS) /\
     < TI, none > := sub4Atts(M, TI, ATTS) /\
     TSB := solveBubbles(T, M, B, VDS, DB) /\
     { T1, S } := metaReduce(M, TSB) /\
     Q := downQid(T') /\
     Q ; SS := getSorts(M) /\
     sameKind(M, Q, S) /\
     sortLeq(M, S, Q) /\
     QIL := '\! '\n 'assertLeqSort '`( metaPrettyPrint(M, TSB, printOpts) '`, Q '`) '
            '\g 'passed. '\o '\n .
 ceq procProps(M, 'assertLeqSort[T, 'token[T']], VDS, B, DB, SYS) = [1, 0, QIL, SYS]
  if not (getAtts(SYS) :: Term) /\
     TSB := solveBubbles(T, M, B, VDS, DB) /\
     { T1, S } := metaReduce(M, TSB) /\
     Q := downQid(T') /\
     Q ; SS := getSorts(M) /\
     sameKind(M, Q, S) /\
     sortLeq(M, S, Q) /\
     QIL := '\! '\n 'assertLeqSort '`( metaPrettyPrint(M, TSB, printOpts) '`, Q '`) '
            '\g 'passed. '\o '\n .
 ceq procProps(M, 'assertLeqSort['bubble[T], 'token[T']], VDS, B, DB, SYS) = [1, 0, QIL, SYS]
  if ATTS := getAtts(SYS) /\
     < TI, SB > := sub4Atts(M, T, ATTS) /\
     SB =/= none /\
     TIS := solveBubbles('bubble[TI], M, B, VDS, DB) /\
     TIS' := applySb(TIS, SB) /\
     { T1, S } := metaReduce(M, TIS') /\
     Q := downQid(T') /\
     Q ; SS := getSorts(M) /\
     sameKind(M, Q, S) /\
     sortLeq(M, S, Q) /\
     QIL := '\! '\n 'assertLeqSort '`( downQidList(T) '`, Q '`) '
            '\g 'passed. '\o '\n .
 ceq procProps(M, 'assertLeqSort[T, 'token[T']], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if 'bubble[TI] := T /\
     ATTS := getAtts(SYS) /\
     < TI, none > := sub4Atts(M, TI, ATTS) /\
     TSB := solveBubbles(T, M, B, VDS, DB) /\
     { T1, S } := metaReduce(M, TSB) /\
     Q := downQid(T') /\
     Q ; SS := getSorts(M) /\
     sameKind(M, Q, S) /\
     not sortLeq(M, S, Q) /\
     QIL := '\! '\n 'assertLeqSort '`( metaPrettyPrint(M, TSB, printOpts) '`, Q '`) '
            '\r 'failed. '\o '\n
            '\n '\! 'The 'normal 'form 'is metaPrettyPrint(M, T1, printOpts)
            '\n 'Its 'sort 'is S .
 ceq procProps(M, 'assertLeqSort[T, 'token[T']], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if not (getAtts(SYS) :: Term) /\
     TSB := solveBubbles(T, M, B, VDS, DB) /\
     { T1, S } := metaReduce(M, TSB) /\
     Q := downQid(T') /\
     Q ; SS := getSorts(M) /\
     sameKind(M, Q, S) /\
     not sortLeq(M, S, Q) /\
     QIL := '\! '\n 'assertLeqSort '`( metaPrettyPrint(M, TSB, printOpts) '`, Q '`) '
            '\r 'failed. '\o '\n
            '\n '\! 'The 'normal 'form 'is metaPrettyPrint(M, T1, printOpts)
            '\n 'Its 'sort 'is S .
 ceq procProps(M, 'assertLeqSort['bubble[T], 'token[T']], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if ATTS := getAtts(SYS) /\
     < TI, SB > := sub4Atts(M, T, ATTS) /\
     SB =/= none /\
     TIS := solveBubbles('bubble[TI], M, B, VDS, DB) /\
     TIS' := applySb(TIS, SB) /\
     { T1, S } := metaReduce(M, TIS') /\
     Q := downQid(T') /\
     Q ; SS := getSorts(M) /\
     sameKind(M, Q, S) /\
     not sortLeq(M, S, Q) /\
     QIL := '\! '\n 'assertLeqSort '`( downQidList(T) '`, Q '`) ' '\r 'failed. '\o '\n
            '\n '\! 'The 'normal 'form 'is metaPrettyPrint(M, T1, printOpts)
            '\n 'Its 'sort 'is S .
 ceq procProps(M, 'assertLeqSort[T, 'token[T']], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if 'bubble[TI] := T /\
     ATTS := getAtts(SYS) /\
     < TI, none > := sub4Atts(M, TI, ATTS) /\
     TSB := solveBubbles(T, M, B, VDS, DB) /\
     { T1, S } := metaReduce(M, TSB) /\
     Q := downQid(T') /\
     Q ; SS := getSorts(M) /\
     not sameKind(M, Q, S) /\
     QIL := '\! '\n 'assertLeqSort '`( metaPrettyPrint(M, TSB, printOpts) '`, Q '`) '
            '\r 'failed. '\o '\n .
 ceq procProps(M, 'assertLeqSort[T, 'token[T']], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if not (getAtts(SYS) :: Term) /\
     TSB := solveBubbles(T, M, B, VDS, DB) /\
     { T1, S } := metaReduce(M, TSB) /\
     Q := downQid(T') /\
     Q ; SS := getSorts(M) /\
     not sameKind(M, Q, S) /\
     QIL := '\! '\n 'assertLeqSort '`( metaPrettyPrint(M, TSB, printOpts) '`, Q '`) '
            '\r 'failed. '\o '\n
            '\n '\! 'The 'normal 'form 'is metaPrettyPrint(M, T1, printOpts)
            '\n 'Its 'sort 'is S .
 ceq procProps(M, 'assertLeqSort['bubble[T], 'token[T']], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if ATTS := getAtts(SYS) /\
     < TI, SB > := sub4Atts(M, T, ATTS) /\
     SB =/= none /\
     TIS := solveBubbles('bubble[TI], M, B, VDS, DB) /\
     TIS' := applySb(TIS, SB) /\
     { T1, S } := metaReduce(M, TIS') /\
     Q := downQid(T') /\
     Q ; SS := getSorts(M) /\
     not sameKind(M, Q, S) /\
     QIL := '\! '\n 'assertLeqSort '`( downQidList(T) '`, Q '`) ' '\r 'failed. '\o '\n
            '\n '\! 'The 'normal 'form 'is metaPrettyPrint(M, T1, printOpts)
            '\n 'Its 'sort 'is S .
 ceq procProps(M, 'assertLeqSort[T, 'token[T']], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if T? := solveBubbles(T, M, B, VDS, DB) /\
     not (T? :: Term) /\
     QIL := ('\n '\r 'Error: '\o getMsg(T?)) [owise] .

 **********************************************************************************
 ********************             assertReachable            **********************
 **********************************************************************************
 ceq procProps(M, 'assertReachable[T, T'], VDS, B, DB, SYS) = [1, 0, QIL, SYS]
  if ATTS := getAtts(SYS) /\
     'bubble[TI] := T /\
     < TI, none > := sub4Atts(M, TI, ATTS) /\
     'bubble[TI'] := T /\
     < TI', none > := sub4Atts(M, TI', ATTS) /\
     T1 := reduce(M, solveBubbles(T, M, B, VDS, DB)) /\
     T2 := reduce(M, solveBubbles(T', M, B, VDS, DB)) /\
     metaSearch(M, T1, T2, nil, '*, unbounded, 0) =/= failure /\
     QIL := '\! '\n 'assertReachable '`( metaPrettyPrint(M, T1, printOpts) '`,
                                         metaPrettyPrint(M, T2, printOpts) '`) '
            '\g 'passed. '\o '\n .
 ceq procProps(M, 'assertReachable[T, T'], VDS, B, DB, SYS) = [1, 0, QIL, SYS]
  if not (getAtts(SYS) :: Term) /\
     T1 := reduce(M, solveBubbles(T, M, B, VDS, DB)) /\
     T2 := reduce(M, solveBubbles(T', M, B, VDS, DB)) /\
     metaSearch(M, T1, T2, nil, '*, unbounded, 0) =/= failure /\
     QIL := '\! '\n 'assertReachable '`( metaPrettyPrint(M, T1, printOpts) '`,
                                         metaPrettyPrint(M, T2, printOpts) '`) '
            '\g 'passed. '\o '\n .
 ceq procProps(M, 'assertReachable['bubble[T], 'bubble[T']], VDS, B, DB, SYS) = [1, 0, QIL, SYS]
  if ATTS := getAtts(SYS) /\
     < TI, SB > := sub4Atts(M, T, ATTS) /\
     < TI1, SB' > := sub4Atts(M, T', ATTS) /\
     ((SB =/= none) or (SB' =/= none)) /\
     TIS := solveBubbles('bubble[TI], M, B, VDS, DB) /\
     TIS' := applySb(TIS, SB) /\
     TIS1 := solveBubbles('bubble[TI1], M, B, VDS, DB) /\
     TIS1' := applySb(TIS1, SB') /\
     T1 := reduce(M, TIS') /\
     T2 := reduce(M, TIS1') /\
     metaSearch(M, T1, T2, nil, '*, unbounded, 0) =/= failure /\
     QIL := '\! '\n 'assertReachable '`( downQidList(T) '`, downQidList(T') '`) '
            '\g 'passed. '\o '\n .
 ceq procProps(M, 'assertReachable[T, T'], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if ATTS := getAtts(SYS) /\
     'bubble[TI] := T /\
     < TI, none > := sub4Atts(M, TI, ATTS) /\
     'bubble[TI'] := T /\
     < TI', none > := sub4Atts(M, TI', ATTS) /\
     T1 := reduce(M, solveBubbles(T, M, B, VDS, DB)) /\
     T2 := reduce(M, solveBubbles(T', M, B, VDS, DB)) /\
     metaSearch(M, T1, T2, nil, '*, unbounded, 0) == failure /\
     QIL := '\! '\n 'assertReachable '`( metaPrettyPrint(M, T1, printOpts) '`,
                                         metaPrettyPrint(M, T2, printOpts) '`) '
            '\r 'failed. '\o '\n .
 ceq procProps(M, 'assertReachable[T, T'], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if not (getAtts(SYS) :: Term) /\
     T1 := reduce(M, solveBubbles(T, M, B, VDS, DB)) /\
     T2 := reduce(M, solveBubbles(T', M, B, VDS, DB)) /\
     metaSearch(M, T1, T2, nil, '*, unbounded, 0) == failure /\
     QIL := '\! '\n 'assertReachable '`( metaPrettyPrint(M, T1, printOpts) '`,
                                         metaPrettyPrint(M, T2, printOpts) '`) '
            '\r 'failed. '\o '\n .
 ceq procProps(M, 'assertReachable['bubble[T], 'bubble[T']], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if ATTS := getAtts(SYS) /\
     < TI, SB > := sub4Atts(M, T, ATTS) /\
     < TI1, SB' > := sub4Atts(M, T', ATTS) /\
     ((SB =/= none) or (SB' =/= none)) /\
     TIS := solveBubbles('bubble[TI], M, B, VDS, DB) /\
     TIS' := applySb(TIS, SB) /\
     TIS1 := solveBubbles('bubble[TI1], M, B, VDS, DB) /\
     TIS1' := applySb(TIS1, SB') /\
     T1 := reduce(M, TIS') /\
     T2 := reduce(M, TIS1') /\
     metaSearch(M, T1, T2, nil, '*, unbounded, 0) == failure /\
     QIL := '\! '\n 'assertReachable '`( downQidList(T) '`, downQidList(T') '`) '
            '\r 'failed. '\o '\n .
 ceq procProps(M, 'assertReachable[T, T'], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if T? := solveBubbles(T, M, B, VDS, DB) /\
     not (T? :: Term) /\
     QIL := ('\n '\r 'Error: '\o getMsg(T?)) .
 ceq procProps(M, 'assertReachable[T, T'], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if T? := solveBubbles(T', M, B, VDS, DB) /\
     not (T? :: Term) /\
     QIL := ('\n '\r 'Error: '\o getMsg(T?)) [owise] .

 **********************************************************************************
 ********************           assertReachableBnd           **********************
 **********************************************************************************
 ceq procProps(M, 'assertReachableBnd[T, T', 'token[T'']], VDS, B, DB, SYS) = [1, 0, QIL, SYS]
  if ATTS := getAtts(SYS) /\
     'bubble[TI] := T /\
     < TI, none > := sub4Atts(M, TI, ATTS) /\
     'bubble[TI'] := T /\
     < TI', none > := sub4Atts(M, TI', ATTS) /\
     T1 := reduce(M, solveBubbles(T, M, B, VDS, DB)) /\
     T2 := reduce(M, solveBubbles(T', M, B, VDS, DB)) /\
     N := rat(string(downQid(T'')), 10) /\
     metaSearch(M, T1, T2, nil, '*, N, 0) =/= failure /\
     QIL := '\! '\n 'assertReachableBnd '`( metaPrettyPrint(M, T1, printOpts) '`,
                                            metaPrettyPrint(M, T2, printOpts) '`,
                                            downQid(T'') '`) ' '\g 'passed. '\o '\n .
 ceq procProps(M, 'assertReachableBnd[T, T', 'token[T'']], VDS, B, DB, SYS) = [1, 0, QIL, SYS]
  if not (getAtts(SYS) :: Term) /\
     T1 := reduce(M, solveBubbles(T, M, B, VDS, DB)) /\
     T2 := reduce(M, solveBubbles(T', M, B, VDS, DB)) /\
     N := rat(string(downQid(T'')), 10) /\
     metaSearch(M, T1, T2, nil, '*, N, 0) =/= failure /\
     QIL := '\! '\n 'assertReachableBnd '`( metaPrettyPrint(M, T1, printOpts) '`,
                                            metaPrettyPrint(M, T2, printOpts) '`,
                                            downQid(T'') '`) ' '\g 'passed. '\o '\n .
 ceq procProps(M, 'assertReachableBnd['bubble[T], 'bubble[T'], 'token[T'']], VDS,
               B, DB, SYS) = [1, 0, QIL, SYS]
  if ATTS := getAtts(SYS) /\
     < TI, SB > := sub4Atts(M, T, ATTS) /\
     < TI1, SB' > := sub4Atts(M, T', ATTS) /\
     ((SB =/= none) or (SB' =/= none)) /\
     TIS := solveBubbles('bubble[TI], M, B, VDS, DB) /\
     TIS' := applySb(TIS, SB) /\
     TIS1 := solveBubbles('bubble[TI1], M, B, VDS, DB) /\
     TIS1' := applySb(TIS1, SB') /\
     T1 := reduce(M, TIS') /\
     T2 := reduce(M, TIS1') /\
     N := rat(string(downQid(T'')), 10) /\
     metaSearch(M, T1, T2, nil, '*, N, 0) =/= failure /\
     QIL := '\! '\n 'assertReachableBnd '`( downQidList(T) '`, downQidList(T') '`,
                                            downQid(T'') '`) ' '\g 'passed. '\o '\n .
 ceq procProps(M, 'assertReachableBnd[T, T', 'token[T'']], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if ATTS := getAtts(SYS) /\
     'bubble[TI] := T /\
     < TI, none > := sub4Atts(M, TI, ATTS) /\
     'bubble[TI'] := T /\
     < TI', none > := sub4Atts(M, TI', ATTS) /\
     T1 := reduce(M, solveBubbles(T, M, B, VDS, DB)) /\
     T2 := reduce(M, solveBubbles(T', M, B, VDS, DB)) /\
     N := rat(string(downQid(T'')), 10) /\
     metaSearch(M, T1, T2, nil, '*, N, 0) == failure /\
     QIL := '\! '\n 'assertReachableBnd '`( metaPrettyPrint(M, T1, printOpts) '`,
                                            metaPrettyPrint(M, T2, printOpts) '`,
                                            downQid(T'') '`) ' '\r 'failed. '\o '\n .
 ceq procProps(M, 'assertReachableBnd[T, T', 'token[T'']], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if not (getAtts(SYS) :: Term) /\
     T1 := reduce(M, solveBubbles(T, M, B, VDS, DB)) /\
     T2 := reduce(M, solveBubbles(T', M, B, VDS, DB)) /\
     N := rat(string(downQid(T'')), 10) /\
     metaSearch(M, T1, T2, nil, '*, N, 0) == failure /\
     QIL := '\! '\n 'assertReachableBnd '`( metaPrettyPrint(M, T1, printOpts) '`,
                                            metaPrettyPrint(M, T2, printOpts) '`,
                                            downQid(T'') '`) ' '\r 'failed. '\o '\n .
 ceq procProps(M, 'assertReachableBnd['bubble[T], 'bubble[T'], 'token[T'']], VDS,
               B, DB, SYS) = [0, 1, QIL, SYS]
  if ATTS := getAtts(SYS) /\
     < TI, SB > := sub4Atts(M, T, ATTS) /\
     < TI1, SB' > := sub4Atts(M, T', ATTS) /\
     ((SB =/= none) or (SB' =/= none)) /\
     TIS := solveBubbles('bubble[TI], M, B, VDS, DB) /\
     TIS' := applySb(TIS, SB) /\
     TIS1 := solveBubbles('bubble[TI1], M, B, VDS, DB) /\
     TIS1' := applySb(TIS1, SB') /\
     T1 := reduce(M, TIS') /\
     T2 := reduce(M, TIS1') /\
     N := rat(string(downQid(T'')), 10) /\
     metaSearch(M, T1, T2, nil, '*, N, 0) == failure /\
     QIL := '\! '\n 'assertReachableBnd '`( downQidList(T) '`, downQidList(T') '`,
                                            downQid(T'') '`) ' '\r 'failed. '\o '\n .
 ceq procProps(M, 'assertReachableBnd[T, T', 'token[T'']], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if not (rat(string(downQid(T'')), 10) :: Nat) /\
     QIL := ('\n '\r 'Error: '\o 'Not 'a 'number) .
 ceq procProps(M, 'assertReachableBnd[T, T', T''], VDS, B, DB, SYS) = [0, 1, QIL, SYS]
  if T? := solveBubbles(T, M, B, VDS, DB) /\
     not (T? :: Term) /\
     QIL := ('\n '\r 'Error: '\o getMsg(T?)) [owise] .

 **********************************************************************************
 **********************************************************************************
 ********************          AUXILIARY FUNCTIONS           **********************
 **********************************************************************************
 **********************************************************************************

 op applySb : Term Substitution -> Term .
 eq applySb(Q[TL], SB) = Q[applySb*(TL, SB)] .
 eq applySb(C, SB) = C .
 eq applySb(V, V <- T ; SB) = T .
 eq applySb(V, SB) = V [owise] .

 op applySb* : TermList Substitution -> TermList .
 eq applySb*(empty, SB) = empty .
 eq applySb*((T, TL), SB) = applySb(T, SB), applySb*(TL, SB) .
endfm

